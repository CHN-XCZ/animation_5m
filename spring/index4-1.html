<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>满屏粘连方块（路径记录+即时回弹版）</title>
  <style>
    html, body { height:100%; margin:0; background:#0b0f14 }
    canvas { position:fixed; inset:0; display:block; width:100%; height:100% }
    .ui{
      position:fixed; left:16px; top:16px; bottom:16px; width:max(260px,22vw);
      display:flex; flex-direction:column; gap:12px; z-index:10;
      background:#0f141b; border:1px solid #2a3340; border-radius:12px; padding:12px; overflow:auto
    }
    .row{ display:flex; flex-direction:column; gap:6px }
    .h{ margin:0; font:700 12px/1 ui-sans-serif,system-ui; color:#cdd6f4; opacity:.8 }
    .label{ display:flex; justify-content:space-between; align-items:center; font:12px/1 ui-sans-serif,system-ui; color:#cdd6f4 }
    .val{ color:#e6eefc; font-weight:700; margin-left:8px; min-width:84px; text-align:right }
    input[type=range]{ width:100% }
    .btn{
      cursor:pointer; border:1px solid #2a3340; background:#101825; color:#e6eefc;
      padding:8px 12px; border-radius:10px; font:600 12px/1 ui-sans-serif,system-ui; margin-bottom:6px
    }
    .btn[aria-pressed="true"]{ background:#1b2a40; border-color:#314257 }
    .err{
      position:fixed; left:16px; bottom:16px; color:#ffebee; background:#3b1d22; border:1px solid #6b2a36;
      border-radius:8px; padding:8px 10px; font:12px/1.4 ui-sans-serif,system-ui; max-width:70ch; white-space:pre-wrap;
      z-index:10; display:none
    }
  </style>
</head>
<body>
  <canvas id="gl"></canvas>
  <canvas id="fallback" style="z-index:-1"></canvas>

  <div class="ui" id="controls">
    <button id="pulse" class="btn" aria-pressed="false">脉动：关 (P)</button>
    <button id="pluck" class="btn" aria-pressed="true">拨动：开 (O)</button>

    <div class="row">
      <h3 class="h">方块</h3>
      <div class="label">尺寸 <span id="vSize" class="val"></span></div>
      <input id="sizeRange" type="range" min="0" max="200" step="0.5" />
      <div class="label">圆角(px) <span id="vRadius" class="val"></span></div>
      <input id="radiusRange" type="range" min="0" max="100" step="0.5" />
      <div class="label">圆角AA(px) <span id="vAA" class="val"></span></div>
      <input id="aaRange" type="range" min="0" max="4" step="0.05" />
    </div>

    <div class="row">
      <h3 class="h">间距（边到边，可为负）</h3>
      <div class="label">水平间距 ΔX <span id="vGapX" class="val"></span></div>
      <input id="gapXRange" type="range" min="-200" max="200" step="0.5" />
      <div class="label">垂直间距 ΔY <span id="vGapY" class="val"></span></div>
      <input id="gapYRange" type="range" min="-200" max="200" step="0.5" />
      <div class="label">当前实际：X/Y <span id="vGapReal" class="val"></span></div>
    </div>

    <div class="row">
      <h3 class="h">粘连/阈值</h3>
      <div class="label">连接范围 <span id="vCR" class="val"></span></div>
      <input id="crRange" type="range" min="0" max="12" step="0.1" />
      <div class="label">阈值 <span id="vTh" class="val"></span></div>
      <input id="thRange" type="range" min="0.1" max="4" step="0.01" />
      <div class="label">连接柔边(φ-AA) <span id="vPhiAA" class="val"></span></div>
      <input id="phiAARange" type="range" min="0.0" max="1.5" step="0.01" />
      <div class="label">角偏置 Corner Bias <span id="vCBias" class="val"></span></div>
      <input id="cbiasRange" type="range" min="0.2" max="2.5" step="0.01" />
    </div>

    <div class="row">
      <h3 class="h">脉动（默认关）</h3>
      <div class="label">速度 <span id="vSpeed" class="val"></span></div>
      <input id="speedRange" type="range" min="0" max="3" step="0.01" />
    </div>

    <div class="row">
      <h3 class="h">拨动波</h3>
      <div class="label">速度→强度比例 <span id="vRatio" class="val"></span></div>
      <input id="ratioRange" type="range" min="0" max="0.1" step="0.001" />
      <div class="label">释放延时(ms, 轨迹尾巴) <span id="vDelay" class="val"></span></div>
      <input id="delayRange" type="range" min="0" max="500" step="10" />
      <div class="label">σ <span id="vSig" class="val"></span></div>
      <input id="sigRange" type="range" min="10" max="400" step="1" />
      <div class="label">λ <span id="vLam" class="val"></span></div>
      <input id="lamRange" type="range" min="20" max="800" step="1" />
      <div class="label">f(Hz) <span id="vFq" class="val"></span></div>
      <input id="fqRange" type="range" min="0" max="5" step="0.01" />
      <div class="label">γ <span id="vGam" class="val"></span></div>
      <input id="gamRange" type="range" min="0" max="4" step="0.01" />
    </div>

    <div class="row">
      <h3 class="h">拨动控制范围（即时回弹）</h3>
      <div class="label">半径 R(px) <span id="vCtrlR" class="val"></span></div>
      <input id="ctrlRRange" type="range" min="40" max="600" step="1" />
      <div class="label">离开释放延时(ms) <span id="vLeaveDelay" class="val"></span></div>
      <input id="leaveDelayRange" type="range" min="0" max="400" step="10" />
      <div class="label">离开释放增益 <span id="vRelGain" class="val"></span></div>
      <input id="relGainRange" type="range" min="0" max="1.5" step="0.01" />
      <button id="autoRecoverBtn" class="btn" aria-pressed="true">离开即恢复：开</button>
    </div>

    <div class="row">
      <h3 class="h">速度绑定</h3>
      <div style="display:flex;gap:6px;flex-wrap:wrap">
        <button id="bindAmp" class="btn" aria-pressed="true">amp↔速：正比</button>
        <button id="bindSig" class="btn" aria-pressed="true">σ↔速：正比</button>
        <button id="bindLam" class="btn" aria-pressed="true">λ↔速：正比</button>
        <button id="bindFq"  class="btn" aria-pressed="true">f↔速：正比</button>
        <button id="bindGam" class="btn" aria-pressed="true">γ↔速：正比</button>
      </div>
      <div class="label">速度上限(px/s) <span id="vSCap" class="val"></span></div>
      <input id="speedCapRange" type="range" min="200" max="4000" step="10" />
      <div class="label">映射强度 <span id="vSEff" class="val"></span></div>
      <input id="speedEffRange" type="range" min="0" max="2" step="0.01" />
      <div class="label">当前速度 <span id="vMS" class="val"></span></div>
    </div>
  </div>

  <div id="err" class="err"></div>

  <script>
(() => {
  // ———— 存储 ————
  const STORE = 'stickySquares.xyGap.aa.v7';
  const saved = (()=>{ try{ return JSON.parse(localStorage.getItem(STORE)||'null'); }catch{ return null; }})();

  // 工具
  const snap05 = v => Math.round(v*2)/2;
  const clamp  = (v,lo,hi)=>Math.max(lo,Math.min(hi,v));

  // ———— 视觉参数 ————
  const CFG = {
    size: snap05(saved?.size ?? 24),
    corner: snap05(saved?.corner ?? 8),
    aa: saved?.aa ?? 1.0,
    pulseSpeedHz: 0.3,
    pulseMin: 0.0,
    connectRange: saved?.connectRange ?? 2.0,
    threshold: saved?.threshold ?? 1.0,
    phiAA: saved?.phiAA ?? 0.20,
    cornerBias: saved?.cornerBias ?? 1.00
  };

  // ———— 间距 ————
  const GAP = { x: snap05(saved?.gapX ?? 8), y: snap05(saved?.gapY ?? 8) };
  const CELL = {
    stepX: snap05(saved?.stepX ?? (2*CFG.size + GAP.x)),
    stepY: snap05(saved?.stepY ?? (1*CFG.size + GAP.y))
  };

  // ———— 拨动波 ————
  const WAVE  = { amp:saved?.amp??20, sigma:saved?.sigma??30, lambda:saved?.lambda??68, freq:saved?.freq??1.2, gamma:saved?.gamma??1.0 };
  const PLUCK = { ratio:saved?.ratio??0.001, delayMs:saved?.delayMs??100, speedThreshold:60 }; // 轨迹尾巴释放延时
  const AMP_CAP = 20;

  // ———— 控制范围（即时回弹） ————
  const CTRL = {
    influenceR: saved?.influenceR ?? 140,     // CSS px
    leaveDelayMs: saved?.leaveDelayMs ?? 0,   // 离开释放延时（默认 0ms 立即回弹）
    releaseGain: saved?.releaseGain ?? 1.0,   // 离开释放强度倍率
    autoRecover: saved?.autoRecover ?? true
  };

  // ———— 速度绑定 ————
  const SPEEDBIND = { capPx:saved?.capPx??1600, effect:saved?.effect??1.0, ampDir:true, sigDir:true, lamDir:true, fqDir:true, gamDir:true };

  function persist(){
    localStorage.setItem(STORE, JSON.stringify({
      size:CFG.size, corner:CFG.corner, aa:CFG.aa,
      gapX:GAP.x, gapY:GAP.y, stepX:CELL.stepX, stepY:CELL.stepY,
      connectRange:CFG.connectRange, threshold:CFG.threshold, phiAA:CFG.phiAA, cornerBias:CFG.cornerBias,
      amp:WAVE.amp, sigma:WAVE.sigma, lambda:WAVE.lambda, freq:WAVE.freq, gamma:WAVE.gamma,
      ratio:PLUCK.ratio, delayMs:PLUCK.delayMs,
      capPx:SPEEDBIND.capPx, effect:SPEEDBIND.effect,
      influenceR:CTRL.influenceR, leaveDelayMs:CTRL.leaveDelayMs, releaseGain:CTRL.releaseGain, autoRecover:CTRL.autoRecover
    }));
  }

  // ———— WebGL 基础 ————
  const DPR = Math.min(2, window.devicePixelRatio || 1);
  const glCanvas = document.getElementById('gl');
  const fbCanvas = document.getElementById('fallback');
  const errBox = document.getElementById('err');

  const controls = document.getElementById('controls');
  ['pointerdown','pointermove','pointerup','wheel','touchstart','touchmove','mousedown','mousemove','mouseup']
    .forEach(ev => controls.addEventListener(ev, e => { e.stopPropagation(); }, {passive:false}));

  function showErr(msg){ errBox.style.display='block'; errBox.textContent=msg; fbCanvas.style.zIndex='1'; }

  const gl = glCanvas.getContext('webgl', { antialias:false, alpha:false });
  if(!gl){ showErr('未启用 WebGL，已回退 Canvas2D。'); startFallback(); return; }

  const VERT = `
  attribute vec2 a_pos;
  void main(){ gl_Position = vec4(a_pos,0.0,1.0); }`;

  // taps 容量（增至 64，仍在常见设备可承受范围）
  const MAX_TAPS = 64;

  // 导数扩展用于 fwidth AA
  const hasDeriv = !!gl.getExtension('OES_standard_derivatives');

  function buildFragSrc(){
    return `
${hasDeriv ? '#extension GL_OES_standard_derivatives : enable' : ''}
#ifdef GL_ES
  #ifdef GL_FRAGMENT_PRECISION_HIGH
    precision highp float;
  #else
    precision mediump float;
  #endif
#else
  precision highp float;
#endif

uniform vec2  u_res;
uniform float u_time;

// 栅格/形状
uniform vec2  u_half0;
uniform vec4  u_radius4;
uniform vec2  u_step;
uniform float u_pulseMin, u_pulseHz;
uniform float u_thresh, u_falloff, u_aa;

// 拨动
uniform float u_amp, u_sigma, u_lambda, u_freq, u_gamma;

// φ 阈值 AA + 角偏置
uniform float u_phiAA;
uniform float u_cornerBias;

uniform float u_tapCount;
uniform vec4  u_taps[${MAX_TAPS}];     // (x,y,t0,angle)
uniform float u_tapGain[${MAX_TAPS}];  // 0..1

float sdRoundBoxCorners(vec2 p, vec2 b, vec4 r4){
  vec2 s = sign(p);
  float r = (s.x>0.0) ? ((s.y>0.0)? r4.x : r4.w)
                      : ((s.y>0.0)? r4.y : r4.z);
  r = clamp(r, 0.0, min(b.x,b.y)-1.0);
  vec2 q = abs(p) - (b - vec2(r));
  return length(max(q, vec2(0.0))) - r;
}

float cornerMask(vec2 p, vec2 b, vec4 r4){
  float rr = min(min(r4.x,r4.y), min(r4.z,r4.w));
  vec2 q = abs(p) - (b - vec2(rr));
  float cx = step(0.0, q.x), cy = step(0.0, q.y);
  return cx * cy;
}

vec2 waveDisplacement(vec2 p){
  vec2 disp = vec2(0.0);
  for(int i=0;i<${MAX_TAPS};i++){
    float mask = step(float(i), u_tapCount);
    vec4 tp = u_taps[i];
    vec2 toP = p - tp.xy;
    float r   = length(toP) + 1e-3;
    float age = max(0.0, u_time - tp.z);

    float env   = exp(-u_gamma*age) * exp(-r/u_sigma);
    float phase = 6.2831853 * u_freq * age - r / u_lambda;
    vec2  dir   = vec2(cos(tp.w), sin(tp.w));

    float a = (u_amp * u_tapGain[i]) * env * cos(phase) * mask;
    disp += dir * a;
  }
  return disp;
}

void main(){
  vec2 uv = gl_FragCoord.xy;
  vec2 C  = u_res * 0.5;

  vec2 uv2 = uv - waveDisplacement(uv);

  float phase = 0.5 + 0.5 * sin(6.2831853 * u_pulseHz * u_time);
  float pulse = u_pulseMin + (1.0 - u_pulseMin) * phase;

  float dmin = 1e6;
  float insideF = 0.0;
  float phi = 0.0;

  float jBase = floor((uv2.y - C.y) / u_step.y + 0.5);
  for(int jy=-1;jy<=1;jy++){
    float j = jBase + float(jy);
    float rowOff = mod(abs(j), 2.0) * 0.5;
    float iBase = floor((uv2.x - C.x - rowOff*u_step.x) / u_step.x + 0.5);
    for(int ix=-1; ix<=1; ix++){
      float i = iBase + float(ix);
      vec2 center = vec2(C.x + (i + rowOff) * u_step.x,
                         C.y +  j            * u_step.y);

      vec2 hSize  = u_half0 * pulse;
      vec4 r4     = u_radius4 * pulse;

      vec2 lp = uv2 - center;
      float d     = sdRoundBoxCorners(lp, hSize, r4);
      dmin = min(dmin, d);
      if(d <= 0.0) insideF = 1.0;

      float wCorner = cornerMask(lp, hSize, r4);
      float w = mix(1.0, u_cornerBias, wCorner);
      phi += w * exp(-u_falloff * max(d, 0.0));
    }
  }

  float wAA = max(u_phiAA, 0.0001);
  ${hasDeriv ? 'wAA = max(wAA, fwidth(phi));' : ''}
  float connected = smoothstep(u_thresh - wAA, u_thresh + wAA, phi);

  float edge = clamp(1.0 - smoothstep(0.0, u_aa, dmin), 0.0, 1.0);
  float mask = (insideF > 0.5) ? 1.0 : connected;
  mask = max(mask, edge * 0.95);

  gl_FragColor = vec4(vec3(mask), 1.0);
}`; }

  const FRAG = buildFragSrc();

  // 编译/链接
  function compile(type, src){
    const s = gl.createShader(type);
    gl.shaderSource(s, src);
    gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
      const log = gl.getShaderInfoLog(s) || '(empty log)';
      gl.deleteShader(s); throw new Error(log);
    }
    return s;
  }
  let prog;
  try{
    prog = gl.createProgram();
    gl.attachShader(prog, compile(gl.VERTEX_SHADER, VERT));
    gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, FRAG));
    gl.linkProgram(prog);
    if(!gl.getProgramParameter(prog, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(prog));
  }catch(e){
    showErr('WebGL 着色器失败：' + e.message + '。已回退 Canvas2D。');
    startFallback(); return;
  }
  gl.useProgram(prog);

  // 大三角
  const buf = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buf);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 3,-1, -1,3]), gl.STATIC_DRAW);
  const a_pos = gl.getAttribLocation(prog, 'a_pos');
  gl.enableVertexAttribArray(a_pos);
  gl.vertexAttribPointer(a_pos, 2, gl.FLOAT, false, 0, 0);

  // uniforms
  const U = n => gl.getUniformLocation(prog, n);
  const u_res = U('u_res'), u_time = U('u_time');
  const u_half0 = U('u_half0'), u_radius4 = U('u_radius4'), u_step = U('u_step');
  const u_pulseMin = U('u_pulseMin'), u_pulseHz = U('u_pulseHz');
  const u_thresh = U('u_thresh'), u_falloff = U('u_falloff'), u_aa = U('u_aa');
  const u_amp = U('u_amp'), u_sigma = U('u_sigma'), u_lambda = U('u_lambda'), u_freq = U('u_freq'), u_gamma = U('u_gamma');
  const u_tapCount = U('u_tapCount');
  const u_phiAA = U('u_phiAA');
  const u_cornerBias = U('u_cornerBias');
  const u_tapEls = [], u_gainEls = [];
  for(let i=0;i<MAX_TAPS;i++){ u_tapEls.push(U(`u_taps[${i}]`)); u_gainEls.push(U(`u_tapGain[${i}]`)); }

  function syncGrid(){
    const sx = Math.round(Math.max(2, CELL.stepX*DPR));
    const sy = Math.round(Math.max(2, CELL.stepY*DPR));
    gl.uniform2f(u_step, sx, sy);
  }
  function syncStatics(){
    const side = snap05(CFG.size);
    const halfPx = Math.round((side*DPR)/2);
    gl.uniform2f(u_half0, halfPx, halfPx);
    const r = snap05(CFG.corner);
    gl.uniform4f(u_radius4, r*DPR, r*DPR, r*DPR, r*DPR);

    gl.uniform1f(u_aa, Math.max(0.0, CFG.aa*DPR));
    gl.uniform1f(u_thresh, CFG.threshold);
    gl.uniform1f(u_falloff, Math.log(2.0)/(Math.max(1e-3, CFG.connectRange)*DPR));
    gl.uniform1f(u_phiAA, CFG.phiAA);
    gl.uniform1f(u_cornerBias, CFG.cornerBias);

    gl.uniform1f(u_amp, WAVE.amp);
    gl.uniform1f(u_sigma, WAVE.sigma*DPR);
    gl.uniform1f(u_lambda, WAVE.lambda*DPR);
    gl.uniform1f(u_freq, WAVE.freq);
    gl.uniform1f(u_gamma, WAVE.gamma);

    syncGrid();
    applyPulseUniforms();
  }

  function resize(){
    const w = Math.floor(innerWidth*DPR), h = Math.floor(innerHeight*DPR);
    glCanvas.width = w; glCanvas.height = h;
    glCanvas.style.width = innerWidth+'px'; glCanvas.style.height = innerHeight+'px';
    gl.viewport(0,0,w,h); gl.uniform2f(u_res, w,h);
  }
  addEventListener('resize', resize);

  // ———— taps 缓冲 ————
  const taps = new Float32Array(MAX_TAPS*4);
  const gains= new Float32Array(MAX_TAPS);
  let tapCount=0, tapPtr=0;
  function uploadTaps(){
    const n = Math.min(tapCount, MAX_TAPS);
    gl.uniform1f(u_tapCount, n);
    for(let i=0;i<MAX_TAPS;i++){
      const loc=u_tapEls[i], gloc=u_gainEls[i];
      if(i<n){ const j=i*4; gl.uniform4f(loc, taps[j],taps[j+1],taps[j+2],taps[j+3]); gl.uniform1f(gloc, gains[i]); }
      else   { gl.uniform4f(loc, 0,0,0,0); gl.uniform1f(gloc, 0); }
    }
  }
  function pushTap(x,y,angle,t0,gain01){
    taps[tapPtr*4+0]=x; taps[tapPtr*4+1]=y; taps[tapPtr*4+2]=t0; taps[tapPtr*4+3]=angle;
    gains[tapPtr]=clamp(gain01||0,0,1);
    tapPtr=(tapPtr+1)%MAX_TAPS; tapCount=Math.min(tapCount+1, MAX_TAPS);
    uploadTaps();
  }

  // ———— 释放“调度队列”（防止占满 uniform） ————
  const sched = []; // {x,y,angle,when,gain}
  function scheduleTap(x,y,angle,when,gain){
    sched.push({x,y,angle,when,gain});
    // 按时间排序，简单稳妥
    sched.sort((a,b)=>a.when-b.when);
  }
  function emitScheduled(now){
    // 每帧最多发射一定数量，避免一次性塞满
    let emitted = 0;
    const LIMIT = 16;
    while(sched.length && sched[0].when <= now && emitted < LIMIT){
      const s = sched.shift();
      pushTap(s.x, s.y, s.angle, s.when, s.gain);
      emitted++;
    }
  }

  function gridStepPx(){ return { stepX:Math.max(2, CELL.stepX*DPR), stepY:Math.max(2, CELL.stepY*DPR) }; }
  function nearestCell(x,y){
    const w=glCanvas.width, h=glCanvas.height, Cx=w*0.5, Cy=h*0.5;
    const {stepX, stepY} = gridStepPx();
    const j = Math.floor((y - Cy)/stepY + 0.5);
    const ro= (Math.abs(j)%2)*0.5;
    const i = Math.floor((x - Cx - ro*stepX)/stepX + 0.5);
    const cx = Cx + (i + ro)*stepX, cy = Cy + j*stepY;
    return {i,j,cx,cy};
  }

  let pluckOn=true, pulseOn=false;
  const btnPulse=document.getElementById('pulse'), btnPluck=document.getElementById('pluck');
  function applyPulseUniforms(){ gl.uniform1f(u_pulseMin, pulseOn ? CFG.pulseMin : 1.0); gl.uniform1f(u_pulseHz,  pulseOn ? CFG.pulseSpeedHz : 0.0); }
  function refreshButtons(){
    btnPulse.setAttribute('aria-pressed', pulseOn);
    btnPulse.textContent = `脉动：${pulseOn?'开':'关'} (P)`;
    btnPluck.setAttribute('aria-pressed', pluckOn);
    btnPluck.textContent = `拨动：${pluckOn?'开':'关'} (O)`;
  }
  refreshButtons();
  btnPulse.onclick = ()=>{ pulseOn=!pulseOn; refreshButtons(); applyPulseUniforms(); persist(); };
  btnPluck.onclick = ()=>{ pluckOn=!pluckOn; refreshButtons(); persist(); };
  addEventListener('keydown', e=>{ if(e.key==='p'||e.key==='P') btnPulse.click(); if(e.key==='o'||e.key==='O') btnPluck.click(); });

  // ———— UI 取值 ————
  const id = x => document.getElementById(x);
  const sizeR=id('sizeRange'), radR=id('radiusRange'), aaR=id('aaRange');
  const gapXR=id('gapXRange'), gapYR=id('gapYRange');
  const vSize=id('vSize'), vRad=id('vRadius'), vAA=id('vAA');
  const vGapX=id('vGapX'), vGapY=id('vGapY'), vGapReal=id('vGapReal');
  const spdR=id('speedRange'), vSpd=id('vSpeed');
  const crR=id('crRange'), vCR=id('vCR');
  const thR=id('thRange'), vTh=id('vTh');
  const phiAAR=id('phiAARange'), vPhiAA=id('vPhiAA');
  const cbiasR=id('cbiasRange'), vCBias=id('vCBias');
  const sigR=id('sigRange'), lamR=id('lamRange'), fqR=id('fqRange'), gamR=id('gamRange');
  const vSig=id('vSig'), vLam=id('vLam'), vFq=id('vFq'), vGam=id('vGam');
  const ratioR=id('ratioRange'), vRatio=id('vRatio');
  const delayR=id('delayRange'), vDelay=id('vDelay');
  const speedCapR=id('speedCapRange'), speedEffR=id('speedEffRange');
  const vSCap=id('vSCap'), vSEff=id('vSEff'), vMS=id('vMS');
  const ctrlRR = id('ctrlRRange'), vCtrlR = id('vCtrlR');
  const leaveDelayR = id('leaveDelayRange'), vLeaveDelay=id('vLeaveDelay');
  const relGainR = id('relGainRange'), vRelGain = id('vRelGain');
  const autoRecoverBtn = id('autoRecoverBtn');

  function updateGapReadout(){
    const gx = snap05(CELL.stepX - 2*CFG.size);
    const gy = snap05(CELL.stepY - 1*CFG.size);
    vGapReal.textContent = `${gx.toFixed(1)} / ${gy.toFixed(1)} px`;
  }
  function initSliders(){
    sizeR.value=CFG.size; vSize.textContent=CFG.size.toFixed(1)+' px';
    radR.value=CFG.corner; vRad.textContent=CFG.corner.toFixed(1)+' px';
    aaR.value=CFG.aa; vAA.textContent=CFG.aa.toFixed(2)+' px';

    gapXR.value=GAP.x; vGapX.textContent=GAP.x.toFixed(1)+' px';
    gapYR.value=GAP.y; vGapY.textContent=GAP.y.toFixed(1)+' px';

    spdR.value=CFG.pulseSpeedHz; vSpd.textContent=CFG.pulseSpeedHz.toFixed(2)+' Hz';
    crR.value=CFG.connectRange;  vCR.textContent=CFG.connectRange.toFixed(1)+' px';
    thR.value=CFG.threshold;     vTh.textContent=CFG.threshold.toFixed(2);
    phiAAR.value=CFG.phiAA;      vPhiAA.textContent=CFG.phiAA.toFixed(2);
    cbiasR.value=CFG.cornerBias; vCBias.textContent=CFG.cornerBias.toFixed(2);

    sigR.value=WAVE.sigma; vSig.textContent=WAVE.sigma.toFixed(0)+' px';
    lamR.value=WAVE.lambda; vLam.textContent=WAVE.lambda.toFixed(0)+' px';
    fqR.value=WAVE.freq;   vFq.textContent=WAVE.freq.toFixed(2)+' Hz';
    gamR.value=WAVE.gamma; vGam.textContent=WAVE.gamma.toFixed(2);

    ratioR.value=PLUCK.ratio; vRatio.textContent=PLUCK.ratio.toFixed(3);
    delayR.value=PLUCK.delayMs; vDelay.textContent=PLUCK.delayMs+' ms';

    speedCapR.value=SPEEDBIND.capPx; vSCap.textContent=SPEEDBIND.capPx+' px/s';
    speedEffR.value=SPEEDBIND.effect; vSEff.textContent=SPEEDBIND.effect.toFixed(2);
    vMS.textContent='0 px/s';

    ctrlRR.value = CTRL.influenceR; vCtrlR.textContent = CTRL.influenceR + ' px';
    leaveDelayR.value = CTRL.leaveDelayMs; vLeaveDelay.textContent = CTRL.leaveDelayMs + ' ms';
    relGainR.value = CTRL.releaseGain; vRelGain.textContent = CTRL.releaseGain.toFixed(2);
    autoRecoverBtn.setAttribute('aria-pressed', CTRL.autoRecover);
    autoRecoverBtn.textContent = `离开即恢复：${CTRL.autoRecover ? '开' : '关'}`;

    updateGapReadout();
  }

  sizeR.oninput = ()=>{ CFG.size=snap05(+sizeR.value); vSize.textContent=CFG.size.toFixed(1)+' px'; syncStatics(); updateGapReadout(); persist(); };
  radR.oninput  = ()=>{ CFG.corner=snap05(+radR.value); vRad.textContent=CFG.corner.toFixed(1)+' px'; syncStatics(); persist(); };
  aaR.oninput   = ()=>{ CFG.aa=+aaR.value; vAA.textContent=CFG.aa.toFixed(2)+' px'; syncStatics(); persist(); };
  gapXR.oninput = ()=>{ GAP.x=snap05(+gapXR.value); vGapX.textContent=GAP.x.toFixed(1)+' px'; CELL.stepX=snap05(Math.max(2, 2*CFG.size + GAP.x)); syncGrid(); updateGapReadout(); persist(); };
  gapYR.oninput = ()=>{ GAP.y=snap05(+gapYR.value); vGapY.textContent=GAP.y.toFixed(1)+' px'; CELL.stepY=snap05(Math.max(2, 1*CFG.size + GAP.y)); syncGrid(); updateGapReadout(); persist(); };
  spdR.oninput  = ()=>{ CFG.pulseSpeedHz=+spdR.value; vSpd.textContent=CFG.pulseSpeedHz.toFixed(2)+' Hz'; applyPulseUniforms(); persist(); };
  crR.oninput   = ()=>{ CFG.connectRange=+crR.value; vCR.textContent=CFG.connectRange.toFixed(1)+' px'; gl.uniform1f(u_falloff, Math.log(2.0)/(Math.max(1e-3, CFG.connectRange)*DPR)); persist(); };
  thR.oninput   = ()=>{ CFG.threshold=+thR.value; vTh.textContent=CFG.threshold.toFixed(2); gl.uniform1f(u_thresh, CFG.threshold); persist(); };
  phiAAR.oninput=()=>{ CFG.phiAA=+phiAAR.value; vPhiAA.textContent=CFG.phiAA.toFixed(2); gl.uniform1f(u_phiAA, CFG.phiAA); persist(); };
  cbiasR.oninput=()=>{ CFG.cornerBias=+cbiasR.value; vCBias.textContent=CFG.cornerBias.toFixed(2); gl.uniform1f(u_cornerBias, CFG.cornerBias); persist(); };
  sigR.oninput  = ()=>{ WAVE.sigma=+sigR.value; vSig.textContent=WAVE.sigma.toFixed(0)+' px'; persist(); };
  lamR.oninput  = ()=>{ WAVE.lambda=+lamR.value; vLam.textContent=WAVE.lambda.toFixed(0)+' px'; persist(); };
  fqR.oninput   = ()=>{ WAVE.freq=+fqR.value; vFq.textContent=WAVE.freq.toFixed(2)+' Hz'; persist(); };
  gamR.oninput  = ()=>{ WAVE.gamma=+gamR.value; vGam.textContent=WAVE.gamma.toFixed(2); persist(); };
  ratioR.oninput= ()=>{ PLUCK.ratio=+ratioR.value; vRatio.textContent=PLUCK.ratio.toFixed(3); persist(); };
  delayR.oninput= ()=>{ PLUCK.delayMs=+delayR.value; vDelay.textContent=PLUCK.delayMs+' ms'; persist(); };
  speedCapR.oninput=()=>{ SPEEDBIND.capPx=+speedCapR.value; vSCap.textContent=SPEEDBIND.capPx+' px/s'; persist(); };
  speedEffR.oninput=()=>{ SPEEDBIND.effect=+speedEffR.value; vSEff.textContent=SPEEDBIND.effect.toFixed(2); persist(); };

  ctrlRR.oninput = ()=>{ CTRL.influenceR = +ctrlRR.value; vCtrlR.textContent = CTRL.influenceR + ' px'; persist(); };
  leaveDelayR.oninput=()=>{ CTRL.leaveDelayMs=+leaveDelayR.value; vLeaveDelay.textContent=CTRL.leaveDelayMs + ' ms'; persist(); };
  relGainR.oninput = ()=>{ CTRL.releaseGain = +relGainR.value; vRelGain.textContent = CTRL.releaseGain.toFixed(2); persist(); };
  autoRecoverBtn.onclick = ()=>{
    CTRL.autoRecover = !CTRL.autoRecover;
    autoRecoverBtn.setAttribute('aria-pressed', CTRL.autoRecover);
    autoRecoverBtn.textContent = `离开即恢复：${CTRL.autoRecover ? '开' : '关'}`;
    persist();
  };

  // ———— 受控格子集合（记录径向角与增益） ————
  const activeCells = new Map(); // key -> {cx, cy, angle, gain}
  const trailLog = [];           // 纯记录（可视化/调试用）
  const keyIJ = (i,j)=> i + ',' + j;

  // 计算当前有效频率（考虑速度绑定）
  function mapBySpeed(base, dir){
    const s=Math.max(0, Math.min(1, smoothSpeed/Math.max(1,SPEEDBIND.capPx)));
    const g=1 + s*SPEEDBIND.effect; return dir ? base*g : base/g;
  }
  function currentFreqEff(){
    const f = mapBySpeed(WAVE.freq, SPEEDBIND.fqDir);
    return Math.max(0.01, f);
  }

  function cellsWithinRadius(x, y, Rpx, gain01){
    const out = new Map();
    const { stepX, stepY } = gridStepPx();
    const j0 = Math.floor((y - glCanvas.height*0.5)/stepY + 0.5);
    const rangeJ = Math.ceil(Rpx/stepY) + 1;
    for(let j = j0 - rangeJ; j <= j0 + rangeJ; j++){
      const rowOff = (Math.abs(j)%2)*0.5;
      const cx0 = glCanvas.width*0.5 + rowOff*stepX;
      const cy  = glCanvas.height*0.5 + j*stepY;
      const dxMax = Math.sqrt(Math.max(0, Rpx*Rpx - (cy - y)*(cy - y)));
      const rangeI = Math.ceil((dxMax + stepX)/stepX) + 1;
      const i0 = Math.floor((x - cx0)/stepX + 0.5);
      for(let i = i0 - rangeI; i <= i0 + rangeI; i++){
        const cx = cx0 + i*stepX;
        const d = Math.hypot(cx - x, cy - y);
        if(d <= Rpx){
          const angle = Math.atan2(y - cy, x - cx); // 由格子指向鼠标的径向角
          out.set(keyIJ(i,j), {cx, cy, angle, gain:gain01});
        }
      }
    }
    return out;
  }

  // 离开即释放：相位反转 + 调度
  function releaseCellsLeft(leftMap, now){
    if(!leftMap.size) return;
    const delaySec = CTRL.leaveDelayMs/1000;
    const phaseShiftSec = -0.5 / currentFreqEff(); // π相位反转
    leftMap.forEach(({cx,cy,angle,gain})=>{
      const reverseAngle = angle + Math.PI; // 径向反向
      const when = now + delaySec + phaseShiftSec;
      scheduleTap(cx, cy, reverseAngle, when, Math.min(1, (gain||0.5)*CTRL.releaseGain));
      trailLog.push({cx,cy,type:'leave',t:when});
    });
  }

  // 鼠标/拨动
  const mouse={prevX:0, prevY:0, tPrev:0}; let lastTapTime=0, lastCell=null, lastGain01=0, lastAngle=0;
  let instSpeed=0, smoothSpeed=0;

  addEventListener('pointermove', e=>{
    const rect=glCanvas.getBoundingClientRect();
    const x=(e.clientX-rect.left)*DPR, y=(rect.bottom-e.clientY)*DPR;
    const now=performance.now()*0.001, dt=Math.max(1e-3, now-mouse.tPrev);
    const vx=(x-mouse.prevX)/dt, vy=(y-mouse.prevY)/dt;
    const Rpx = CTRL.influenceR * DPR;

    instSpeed=Math.hypot(vx,vy);
    smoothSpeed = 0.25*instSpeed + 0.75*smoothSpeed;
    vMS.textContent=Math.round(smoothSpeed)+' px/s';

    const cell=nearestCell(x,y);

    if(pluckOn){
      const ampPx=Math.min(AMP_CAP, instSpeed*PLUCK.ratio);
      const gain01=ampPx/AMP_CAP;
      const angle=Math.atan2(vy,vx);

      // 鼠标前向拨动（直接推送）
      if(instSpeed>PLUCK.speedThreshold || (now-lastTapTime)>0.08){
        pushTap(x,y,angle,now,gain01);
        lastTapTime=now; lastGain01=gain01; lastAngle=angle;
      }

      // 半径内集合
      if(CTRL.autoRecover){
        const newActive = cellsWithinRadius(x, y, Rpx, gain01);
        // 找到离开的格子并安排释放
        const left = new Map();
        activeCells.forEach((v,k)=>{ if(!newActive.has(k)) left.set(k, v); });
        releaseCellsLeft(left, now);
        // 更新受控集合
        activeCells.clear(); newActive.forEach((v,k)=> activeCells.set(k,v));
      }

      // 跨格释放（轨迹尾巴），也做相位反转
      if(lastCell && (cell.i!==lastCell.i || cell.j!==lastCell.j)){
        const delaySec=PLUCK.delayMs/1000;
        const phaseShiftSec = -0.5 / currentFreqEff();
        const reverseAngle=lastAngle+Math.PI;
        scheduleTap(lastCell.cx,lastCell.cy, reverseAngle, now+delaySec+phaseShiftSec, lastGain01);
        trailLog.push({cx:lastCell.cx,cy:lastCell.cy,type:'trail',t:now+delaySec+phaseShiftSec});
      }
      lastCell=cell;
    }

    mouse.prevX=x; mouse.prevY=y; mouse.tPrev=now;
  }, {passive:true});

  addEventListener('pointerdown', e=>{
    const rect=glCanvas.getBoundingClientRect();
    const x=(e.clientX-rect.left)*DPR, y=(rect.bottom-e.clientY)*DPR;
    const now=performance.now()*0.001;
    pushTap(x,y,0.0,now,0.5); lastTapTime=now; lastCell=nearestCell(x,y); lastGain01=0.5; lastAngle=0.0;

    if(CTRL.autoRecover){
      const Rpx = CTRL.influenceR * DPR;
      const newActive = cellsWithinRadius(x, y, Rpx, 0.5);
      activeCells.clear(); newActive.forEach((v,k)=> activeCells.set(k,v));
    }
  }, {passive:true});

  ['pointerup','pointerleave','mouseleave','touchend','touchcancel'].forEach(ev=>{
    addEventListener(ev, ()=>{
      if(CTRL.autoRecover && activeCells.size){
        const now=performance.now()*0.001;
        // 全部安排释放
        const left = new Map(activeCells);
        releaseCellsLeft(left, now);
        activeCells.clear();
      }
    }, {passive:true});
  });

  // 渲染循环
  let t0=performance.now();
  function frame(){
    gl.clearColor(0,0,0,1); gl.clear(gl.COLOR_BUFFER_BIT);
    const t=(performance.now()-t0)*0.001;
    gl.uniform1f(u_time,t);

    // 发射到期的释放脉冲（历史记录驱动）
    emitScheduled(t);

    gl.uniform1f(u_amp,    mapBySpeed(WAVE.amp,    SPEEDBIND.ampDir));
    gl.uniform1f(u_sigma,  mapBySpeed(WAVE.sigma,  SPEEDBIND.sigDir)*DPR);
    gl.uniform1f(u_lambda, mapBySpeed(WAVE.lambda, SPEEDBIND.lamDir)*DPR);
    gl.uniform1f(u_freq,   mapBySpeed(WAVE.freq,   SPEEDBIND.fqDir));
    gl.uniform1f(u_gamma,  mapBySpeed(WAVE.gamma,  SPEEDBIND.gamDir));

    gl.drawArrays(gl.TRIANGLES, 0, 3);
    requestAnimationFrame(frame);
  }

  // 启动
  function applyPulseUniforms(){ gl.uniform1f(u_pulseMin, pulseOn ? CFG.pulseMin : 1.0); gl.uniform1f(u_pulseHz,  pulseOn ? CFG.pulseSpeedHz : 0.0); }
  resize(); syncStatics(); initSliders(); applyPulseUniforms(); frame();

  // —— Canvas2D 回退（简版） —— //
  function startFallback(){
    const ctx=fbCanvas.getContext('2d');
    function rr4(ctx,x,y,w,h,r){
      const rr=v=>Math.max(0, Math.min(v, Math.min(w,h)/2 - 0.5)); r=rr(r);
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.lineTo(x+w-r, y); ctx.arcTo(x+w,y, x+w,y+r, r);
      ctx.lineTo(x+w, y+h-r); ctx.arcTo(x+w,y+h, x+w-r,y+h, r);
      ctx.lineTo(x+r, y+h); ctx.arcTo(x,y+h, x,y+h-r, r);
      ctx.lineTo(x, y+r); ctx.arcTo(x,y, x+r,y, r);
      ctx.closePath();
    }
    function resize2(){ fbCanvas.width=innerWidth; fbCanvas.height=innerHeight; }
    function draw(){
      ctx.clearRect(0,0,fbCanvas.width,fbCanvas.height);
      const s=snap05(CFG.size), half=s*0.5, r=snap05(CFG.corner);
      const stepX=CELL.stepX, stepY=CELL.stepY;
      const Cx=fbCanvas.width/2, Cy=fbCanvas.height/2;

      const t=performance.now()*0.001;
      const k=pulseOn ? (CFG.pulseMin + (1-CFG.pulseMin)*(0.5+0.5*Math.sin(CFG.pulseSpeedHz*2*Math.PI*t))) : 1.0;
      const h2=half*k, r2=Math.min(r*k, h2-0.5);

      ctx.fillStyle='#fff';
      for(let j=-1000;j<=1000;j++){
        const rowOff=(Math.abs(j)%2)*0.5;
        const y=Cy + j*stepY;
        if(y<-s*2 || y>fbCanvas.height+s*2) continue;
        for(let i=-1000;i<=1000;i++){
          const x=Cx + (i+rowOff)*stepX;
          if(x<-s*2 || x>fbCanvas.width+s*2) continue;
          rr4(ctx, x-h2, y-h2, h2*2, h2*2, r2); ctx.fill();
        }
      }
      requestAnimationFrame(draw);
    }
    addEventListener('resize', resize2);
    resize2(); draw();
  }
})();
  </script>
</body>
</html>
