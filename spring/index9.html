<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Squircle · 圆角并集 + 定向拉伸（X-9块 / 十字-9块）— 无动态索引修复</title>
  <style>
    html,
    body {
      height: 100%;
      margin: 0;
      background: #0b0f14
    }

    canvas {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      display: block
    }

    .ui {
      position: fixed;
      left: 16px;
      top: 16px;
      z-index: 10;
      display: grid;
      gap: 10px;
      grid-auto-rows: min-content;
      padding: 12px;
      border: 1px solid #223;
      border-radius: 12px;
      background: rgba(10, 16, 24, .75);
      backdrop-filter: blur(6px);
      color: #e6eefc;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial
    }

    .row {
      display: flex;
      align-items: center;
      gap: 10px
    }

    .row label {
      white-space: nowrap
    }

    input[type="range"] {
      width: 240px
    }

    select {
      padding: 4px 6px;
      background: #101825;
      color: #e6eefc;
      border: 1px solid #2a3340;
      border-radius: 8px
    }

    .value {
      font-variant-numeric: tabular-nums;
      opacity: .9;
      min-width: 6ch;
      text-align: right;
      display: inline-block
    }

    .muted {
      font-size: 12px;
      opacity: .8
    }

    .sep {
      height: 1px;
      background: #223;
      margin: 6px 0 2px
    }
  </style>
</head>

<body>
  <canvas id="gl"></canvas>

  <div class="ui">
    <div class="row"><label><input id="toggleGrid" type="checkbox"> 显示网格</label></div>
    <div class="row">
      <label for="grid">网格间隔</label>
      <input id="grid" type="range" min="8" max="240" step="1"><span class="value" id="gridVal"></span>
    </div>

    <div class="sep"></div>
    <div class="row">
      <label for="layout">排列</label>
      <select id="layout">
        <option value="0">X-9块（中心+两条对角各±1、±2）</option>
        <option value="1">十字-9块（中心+上下左右各±1、±2）</option>
      </select>
    </div>
    <div class="row">
      <label for="size">方块大小</label>
      <input id="size" type="range" min="0" max="150" step="1"><span class="value" id="sizeVal"></span>
    </div>

    <div class="row">
      <label for="roundR">连接圆角</label>
      <input id="roundR" type="range" min="0" max="60" step="1"><span class="value" id="roundRVal"></span>
    </div>
    <div class="row">
      <label for="pExp">P 指数</label>
      <input id="pExp" type="range" min="3" max="8" step="1"><span class="value" id="pExpVal"></span>
    </div>

    <div class="sep"></div>
    <div class="row">
      <label for="gapStart">并集开始距</label>
      <input id="gapStart" type="range" min="0" max="150" step="1"><span class="value" id="gapStartVal"></span>
    </div>
    <div class="row">
      <label for="gapWidth">过渡宽度</label>
      <input id="gapWidth" type="range" min="0" max="80" step="1"><span class="value" id="gapWidthVal"></span>
    </div>

    <div class="row">
      <label for="stretch">拉伸强度</label>
      <input id="stretch" type="range" min="0" max="100" step="1"><span class="value" id="stretchVal"></span>
    </div>
    <div class="muted">让 45% 尺寸也能“靠拢并集”：拉伸 30%~50%，开始距 30%~50%，过渡 15%~25%，P=5~6，圆角 25%~35%。</div>

    <div class="sep"></div>
    <div class="row">
      <label for="aa">抗锯齿</label>
      <input id="aa" type="range" min="0" max="2" step="0.05"><span class="value" id="aaVal"></span>
    </div>
  </div>

  <script>
    (() => {
      const canvas = document.getElementById('gl');
      /** @type {WebGLRenderingContext} */
      const gl = canvas.getContext('webgl', {
        antialias: false,
        alpha: false,
        premultipliedAlpha: false
      });
      if (!gl) {
        alert('你的浏览器不支持 WebGL。');
        return;
      }

      // ---------- UI + 存储 ----------
      const $ = id => document.getElementById(id);
      const LS_KEY = 'webgl_round_union_x9_cross9_fix_v2';
      const state = Object.assign({
        showGrid: true,
        gridCss: 64,
        layout: 0,
        sizePct: 50,
        roundR: 30,
        pExp: 5,
        gapStart: 40,
        gapWidth: 20,
        stretch: 40,
        aa: 0.85
      }, JSON.parse(localStorage.getItem(LS_KEY) || '{}'));

      function bindRange(id, fmt, key = id) {
        const el = $(id),
          v = $(id + 'Val');
        const sync = () => {
          el.value = String(state[key]);
          v.textContent = fmt(state[key]);
        };
        const on = () => {
          state[key] = +el.value;
          v.textContent = fmt(state[key]);
          localStorage.setItem(LS_KEY, JSON.stringify(state));
        };
        sync();
        el.addEventListener('input', on);
      }
      $('toggleGrid').checked = state.showGrid;
      $('toggleGrid').addEventListener('change', () => {
        state.showGrid = $('toggleGrid').checked;
        localStorage.setItem(LS_KEY, JSON.stringify(state));
      });
      bindRange('grid', v => v + 'px', 'gridCss');

      const layoutSel = $('layout');
      layoutSel.value = String(state.layout);
      layoutSel.addEventListener('change', () => {
        state.layout = +layoutSel.value;
        localStorage.setItem(LS_KEY, JSON.stringify(state));
      });

      bindRange('size', v => v + '%', 'sizePct');
      bindRange('roundR', v => v + '%');
      bindRange('pExp', v => 'P=' + v);
      bindRange('gapStart', v => v + '%');
      bindRange('gapWidth', v => v + '%');
      bindRange('stretch', v => v + '%');
      bindRange('aa', v => (+v).toFixed(2), 'aa');

      // ---------- 着色器 ----------
      const vertSrc = `
  attribute vec2 a_pos;
  void main(){ gl_Position=vec4(a_pos,0.0,1.0); }`;

      const fragSrc = `
  precision highp float;
  uniform vec2  u_resolution;
  uniform float u_grid;
  uniform float u_showGrid;
  uniform float u_layout;       // 0=X-9；1=十字-9
  uniform float u_sizePct;      // 0..150 (% of g)
  uniform float u_roundR;       // % of g
  uniform float u_pExp;         // 3..8
  uniform float u_gapStart;     // % of g
  uniform float u_gapWidth;     // % of g
  uniform float u_stretch;      // % -> 0..1
  uniform float u_aa;           // 像素

  // —— 数学工具 —— //
  vec2 roundVec2(vec2 v){ return sign(v)*floor(abs(v)+0.5); }
  float lengthP(vec2 v, float p){ v=abs(v); return pow(pow(v.x,p)+pow(v.y,p), 1.0/p); }
  float sdfSquircle(vec2 p, float R, float pwr){
    vec2 q=abs(p); return pow(pow(q.x,pwr)+pow(q.y,pwr), 1.0/pwr) - R;
  }
  float opUnionRoundP(float d1, float d2, float r, float pwr){
    vec2 u = max(vec2(r - d1, r - d2), vec2(0.0));
    return max(r, min(d1, d2)) - lengthP(u, pwr);
  }
  float radiusAlongDir(float R, vec2 dir, float pwr){
    vec2 u=abs(normalize(dir));
    float denom = pow(pow(u.x,pwr)+pow(u.y,pwr), 1.0/pwr);
    return R / max(denom,1e-6);
  }
  float gapWeight(float gap, float start, float width){
    return 1.0 - smoothstep(start, start+max(width,0.0), gap);
  }
  float sdfStretchedToward(vec2 p, vec2 c, vec2 dir, float s, float R, float pwr){
    if(s <= 0.0) return 1e9;
    vec2 u = normalize(dir);
    vec2 v = vec2(-u.y, u.x);
    vec2 lp = p - c;
    vec2 loc = vec2(dot(lp,u), dot(lp,v));
    float k = 1.0 + s;
    vec2 q = vec2(loc.x / k, loc.y);
    return sdfSquircle(q, R, pwr);
  }
  float pairUnionRoundStretched(vec2 p, vec2 ci, vec2 cj,
                                float R, float pwr, float r, float start, float width, float stretchMax,
                                float dAcc){
    vec2 dir = normalize(cj - ci);
    float rAlong = radiusAlongDir(R, dir, pwr);
    float gap = length(cj - ci) - 2.0*rAlong;
    float w = gapWeight(gap, start, width);
    float s = w * stretchMax;
    float d1 = min(sdfSquircle(p-ci, R, pwr), sdfStretchedToward(p, ci, dir,  s, R, pwr));
    float d2 = min(sdfSquircle(p-cj, R, pwr), sdfStretchedToward(p, cj, -dir, s, R, pwr));
    float dRound = opUnionRoundP(d1, d2, r, pwr);
    float dPair  = mix(min(d1,d2), dRound, w);
    return min(dAcc, dPair);
  }

  void main(){
    vec2 frag = gl_FragCoord.xy;
    vec2 center = floor(0.5*u_resolution);
    vec2 p = frag - center;

    // 网格（像素对齐）
    float gridCol=0.0;
    if(u_showGrid>0.5){
      float s=max(1.0,u_grid);
      vec2 ij=floor(frag), gc=floor(0.5*u_resolution);
      float rx=abs(mod(ij.x-gc.x,s)), ry=abs(mod(ij.y-gc.y,s));
      float vLine=1.0-step(0.5,rx), hLine=1.0-step(0.5,ry);
      gridCol=min(vLine+hLine,1.0);
    }

    float g = max(1.0,u_grid);
    float R = g * clamp(u_sizePct/100.0, 0.0, 1.5);
    float r = g * max(u_roundR/100.0, 0.0);
    float pwr = clamp(u_pExp, 3.0, 8.0);
    float start = g * max(u_gapStart/100.0, 0.0);
    float width = g * max(u_gapWidth/100.0, 0.0);
    float stretchMax = max(u_stretch/100.0, 0.0);

    // —— 9 个中心（常量展开，无数组/动态索引） —— //
    vec2 C  = vec2(0.0);

    // X-9：两条对角线
    vec2 A1 = vec2( 1.0, 1.0)*g, A2 = vec2( 2.0, 2.0)*g;
    vec2 A_1= vec2(-1.0,-1.0)*g, A_2= vec2(-2.0,-2.0)*g;
    vec2 B1 = vec2( 1.0,-1.0)*g, B2 = vec2( 2.0,-2.0)*g;
    vec2 B_1= vec2(-1.0, 1.0)*g, B_2= vec2(-2.0, 2.0)*g;

    // 十字-9：水平/垂直
    vec2 R1 = vec2( 1.0, 0.0)*g, R2 = vec2( 2.0, 0.0)*g;
    vec2 L1 = vec2(-1.0, 0.0)*g, L2 = vec2(-2.0, 0.0)*g;
    vec2 U1 = vec2( 0.0, 1.0)*g, U2 = vec2( 0.0, 2.0)*g;
    vec2 D1 = vec2( 0.0,-1.0)*g, D2 = vec2( 0.0,-2.0)*g;

    float d = 1e9;

    if(u_layout < 0.5){
      // X-9：按“链路相邻对”合并（完全展开）
      d = pairUnionRoundStretched(p, A_2, A_1, R, pwr, r, start, width, stretchMax, d);
      d = pairUnionRoundStretched(p, A_1, C,   R, pwr, r, start, width, stretchMax, d);
      d = pairUnionRoundStretched(p, C,   A1,  R, pwr, r, start, width, stretchMax, d);
      d = pairUnionRoundStretched(p, A1,  A2,  R, pwr, r, start, width, stretchMax, d);

      d = pairUnionRoundStretched(p, B_2, B_1, R, pwr, r, start, width, stretchMax, d);
      d = pairUnionRoundStretched(p, B_1, C,   R, pwr, r, start, width, stretchMax, d);
      d = pairUnionRoundStretched(p, C,   B1,  R, pwr, r, start, width, stretchMax, d);
      d = pairUnionRoundStretched(p, B1,  B2,  R, pwr, r, start, width, stretchMax, d);
    } else {
      // 十字-9：水平 + 垂直（完全展开）
      d = pairUnionRoundStretched(p, L2, L1, R, pwr, r, start, width, stretchMax, d);
      d = pairUnionRoundStretched(p, L1, C,  R, pwr, r, start, width, stretchMax, d);
      d = pairUnionRoundStretched(p, C,  R1, R, pwr, r, start, width, stretchMax, d);
      d = pairUnionRoundStretched(p, R1, R2, R, pwr, r, start, width, stretchMax, d);

      d = pairUnionRoundStretched(p, D2, D1, R, pwr, r, start, width, stretchMax, d);
      d = pairUnionRoundStretched(p, D1, C,  R, pwr, r, start, width, stretchMax, d);
      d = pairUnionRoundStretched(p, C,  U1, R, pwr, r, start, width, stretchMax, d);
      d = pairUnionRoundStretched(p, U1, U2, R, pwr, r, start, width, stretchMax, d);
    }

    // 抗锯齿
    float shape = smoothstep(u_aa, -u_aa, d);
    float col = max(gridCol, shape);
    gl_FragColor = vec4(vec3(col), 1.0);
  }`;

      function createShader(type, src) {
        const sh = gl.createShader(type);
        gl.shaderSource(sh, src);
        gl.compileShader(sh);
        if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
          const info = gl.getShaderInfoLog(sh);
          gl.deleteShader(sh);
          throw new Error('Shader compile failed: ' + info);
        }
        return sh;
      }

      function createProgram(vs, fs) {
        const v = createShader(gl.VERTEX_SHADER, vs),
          f = createShader(gl.FRAGMENT_SHADER, fs);
        const p = gl.createProgram();
        gl.attachShader(p, v);
        gl.attachShader(p, f);
        gl.linkProgram(p);
        if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
          const info = gl.getProgramInfoLog(p);
          gl.deleteProgram(p);
          throw new Error('Program link failed: ' + info);
        }
        gl.deleteShader(v);
        gl.deleteShader(f);
        return p;
      }

      const program = createProgram(vertSrc, fragSrc);
      gl.useProgram(program);
      const quad = new Float32Array([-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1]);
      const vbo = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
      gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);
      const a_pos = gl.getAttribLocation(program, 'a_pos');
      gl.enableVertexAttribArray(a_pos);
      gl.vertexAttribPointer(a_pos, 2, gl.FLOAT, false, 0, 0);

      const u_resolution = gl.getUniformLocation(program, 'u_resolution');
      const u_grid = gl.getUniformLocation(program, 'u_grid');
      const u_showGrid = gl.getUniformLocation(program, 'u_showGrid');
      const u_layout = gl.getUniformLocation(program, 'u_layout');
      const u_sizePct = gl.getUniformLocation(program, 'u_sizePct');
      const u_roundR = gl.getUniformLocation(program, 'u_roundR');
      const u_pExp = gl.getUniformLocation(program, 'u_pExp');
      const u_gapStart = gl.getUniformLocation(program, 'u_gapStart');
      const u_gapWidth = gl.getUniformLocation(program, 'u_gapWidth');
      const u_stretch = gl.getUniformLocation(program, 'u_stretch');
      const u_aa = gl.getUniformLocation(program, 'u_aa');

      gl.disable(gl.BLEND);

      function resizeCanvas() {
        const dpr = Math.max(1, Math.round(window.devicePixelRatio || 1));
        const w = Math.floor(canvas.clientWidth * dpr),
          h = Math.floor(canvas.clientHeight * dpr);
        if (canvas.width !== w || canvas.height !== h) {
          canvas.width = w;
          canvas.height = h;
          gl.viewport(0, 0, w, h);
        }
        return dpr;
      }

      function draw() {
        const dpr = resizeCanvas();
        gl.clearColor(0, 0, 0, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);

        const gridPhysical = Math.max(1, Math.round(state.gridCss * dpr));

        gl.uniform2f(u_resolution, canvas.width, canvas.height);
        gl.uniform1f(u_grid, gridPhysical);
        gl.uniform1f(u_showGrid, state.showGrid ? 1 : 0);
        gl.uniform1f(u_layout, state.layout);
        gl.uniform1f(u_sizePct, state.sizePct);
        gl.uniform1f(u_roundR, state.roundR);
        gl.uniform1f(u_pExp, state.pExp);
        gl.uniform1f(u_gapStart, state.gapStart);
        gl.uniform1f(u_gapWidth, state.gapWidth);
        gl.uniform1f(u_stretch, state.stretch);
        gl.uniform1f(u_aa, state.aa * dpr);

        gl.drawArrays(gl.TRIANGLES, 0, 6);
        requestAnimationFrame(draw);
      }
      draw();

      Object.assign(canvas.style, {
        left: '0px',
        top: '0px',
        width: '100vw',
        height: '100vh'
      });
    })();
  </script>
</body>

</html>