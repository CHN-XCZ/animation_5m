<!doctype html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>满屏粘连方块 · 解析式栅格（WebGL）</title>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            background: #0b0f14
        }

        canvas {
            position: fixed;
            inset: 0;
            display: block;
            width: 100%;
            height: 100%
        }

        .ui {
            position: fixed;
            left: 16px;
            top: 16px;
            display: flex;
            gap: 8px;
            z-index: 10;
            flex-wrap: wrap;
            align-items: center
        }

        .btn {
            cursor: pointer;
            border: 1px solid #2a3340;
            background: #101825;
            color: #e6eefc;
            padding: 8px 12px;
            border-radius: 10px;
            font: 600 12px/1 ui-sans-serif, system-ui
        }

        .btn[aria-pressed="true"] {
            background: #1b2a40;
            border-color: #314257
        }

        .panel {
            display: flex;
            gap: 12px;
            align-items: center;
            background: #0f141b;
            border: 1px solid #2a3340;
            padding: 8px 12px;
            border-radius: 12px
        }

        .panel label {
            font: 12px/1 ui-sans-serif, system-ui;
            color: #cdd6f4;
            opacity: .95
        }

        .panel input[type=range] {
            width: 160px
        }

        .val {
            min-width: 62px;
            display: inline-block;
            text-align: right;
            color: #e6eefc;
            font-weight: 600
        }

        .err {
            position: fixed;
            left: 16px;
            bottom: 16px;
            color: #ffebee;
            background: #3b1d22;
            border: 1px solid #6b2a36;
            border-radius: 8px;
            padding: 8px 10px;
            font: 12px/1.4 ui-sans-serif, system-ui;
            max-width: 70ch;
            white-space: pre-wrap;
            z-index: 10;
            display: none
        }
    </style>
</head>

<body>
    <canvas id="gl"></canvas>
    <canvas id="fallback" style="z-index:-1"></canvas>

    <div class="ui">
        <button id="pulse" class="btn" aria-pressed="true">脉动：开 (P)</button>
        <div class="panel">
            <label>尺寸 <span id="vSize" class="val"></span>
                <input id="sizeRange" type="range" min="8" max="160" step="1" />
            </label>
            <label>间隔 <span id="vGap" class="val"></span>
                <input id="gapRange" type="range" min="0" max="120" step="1" />
            </label>
            <label>圆角 <span id="vRadius" class="val"></span>
                <input id="radiusRange" type="range" min="0" max="80" step="1" />
            </label>
            <label>脉动速度 <span id="vSpeed" class="val"></span>
                <input id="speedRange" type="range" min="0" max="3" step="0.01" />
            </label>
            <label>连接范围 <span id="vCR" class="val"></span>
                <input id="crRange" type="range" min="0" max="12" step="0.1" />
            </label>
            <label>阈值 <span id="vTh" class="val"></span>
                <input id="thRange" type="range" min="0.1" max="4" step="0.01" />
            </label>
        </div>
    </div>

    <div id="err" class="err"></div>

    <script>
        (() => {
            // —— 参数（无鼠标交互） ——
            const CFG = {
                size: 18, // 方块边长（CSS px）
                corner: 3, // 圆角（CSS px）
                extraGap: 4, // 间隔（CSS px）：竖向=它本身；横向=“空一块”+它
                pulseSpeedHz: 0.3, // 脉动速度
                pulseMin: 0.0, // 最小缩放（0=消失，1=不脉动）
                connectRange: 2.0, // 指数场半衰尺度（像素）
                threshold: 1.0, // 阈值
                aa: 1.0 // 抗锯齿宽度（像素）
            };
            const DPR = Math.min(2, window.devicePixelRatio || 1);

            const glCanvas = document.getElementById('gl');
            const fbCanvas = document.getElementById('fallback');
            const errBox = document.getElementById('err');

            // ——— WebGL ———
            const gl = glCanvas.getContext('webgl', {
                antialias: false,
                alpha: false
            });

            function showErr(msg) {
                errBox.style.display = 'block';
                errBox.textContent = msg;
                fbCanvas.style.zIndex = '1';
            }

            function startWebGL() {
                if (!gl) {
                    showErr('未启用 WebGL，已回退 Canvas2D。');
                    return false;
                }

                const VERT = `
    #ifdef GL_ES
      precision highp float;
    #endif
      attribute vec2 a_pos;
      void main(){ gl_Position = vec4(a_pos,0.0,1.0); }
    `;

                // ★ 片元：把局部变量名从 half 改为 hSize（避免保留字冲突）
                const FRAG = `
    #ifdef GL_ES
      #ifdef GL_FRAGMENT_PRECISION_HIGH
        precision highp float;
      #else
        precision mediump float;
      #endif
    #else
      precision highp float;
    #endif

      uniform vec2  u_res;
      uniform float u_time;
      uniform vec2  u_half0;
      uniform vec4 u_radius4;
      uniform vec2  u_step;
      uniform float u_pulseMin;
      uniform float u_pulseHz;
      uniform float u_thresh;
      uniform float u_falloff;
      uniform float u_aa;

        float sdRoundBoxCorners(vec2 p, vec2 b, vec4 r4){
        // 基于点所处象限选择该角半径
        // (+x,+y)=TR, (-x,+y)=TL, (-x,-y)=BL, (+x,-y)=BR
        vec2 s = sign(p);
        float r = (s.x>0.0) ? ((s.y>0.0)? r4.x : r4.w)
                            : ((s.y>0.0)? r4.y : r4.z);
        // 安全夹取，防止半径超过半边
        r = clamp(r, 0.0, min(b.x, b.y) - 1.0);

        vec2 q = abs(p) - (b - vec2(r));
        return length(max(q, vec2(0.0))) - r;
        }

      void main(){
        vec2 uv = gl_FragCoord.xy;
        vec2 C  = u_res * 0.5;

        float phase = 0.5 + 0.5 * sin(6.2831853 * u_pulseHz * u_time);
        float pulse = u_pulseMin + (1.0 - u_pulseMin) * phase;

        float dmin    = 1e6;
        float phi     = 0.0;
        float insideF = 0.0;

        float jBase = floor((uv.y - C.y) / u_step.y + 0.5);
        for(int jy=-1;jy<=1;jy++){
          float j = jBase + float(jy);
          float rowOff = mod(abs(j), 2.0) * 0.5; // 砖块式错行
          float iBase = floor((uv.x - C.x - rowOff * u_step.x) / u_step.x + 0.5);
          for(int ix=-1; ix<=1; ix++){
            float i = iBase + float(ix);
            vec2 center = vec2(C.x + (i + rowOff) * u_step.x,
                               C.y +  j            * u_step.y);
vec2 hSize  = u_half0 * pulse;
vec4 r4     = u_radius4 * pulse;                  // 脉动时半径也跟着缩放
float d     = sdRoundBoxCorners(uv - center, hSize, r4);

            dmin = min(dmin, d);
            if(d <= 0.0) insideF = 1.0;
            phi += exp(-u_falloff * max(d, 0.0));
          }
        }

        float mask = (insideF > 0.5) ? 1.0 : step(u_thresh, phi);
        float edge = clamp(1.0 - smoothstep(0.0, u_aa, dmin), 0.0, 1.0);
        mask = max(mask, edge * 0.95);
        gl_FragColor = vec4(vec3(mask), 1.0);
      }
    `;

                function compile(type, src) {
                    const s = gl.createShader(type);
                    gl.shaderSource(s, src);
                    gl.compileShader(s);
                    if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
                        const log = gl.getShaderInfoLog(s) || '(empty log)';
                        const numbered = src.split('\n').map((l, i) => String(i + 1).padStart(3, ' ') + ': ' + l)
                            .join('\n');
                        console.error('Shader compile error:\n' + log + '\n\nSource:\n' + numbered);
                        gl.deleteShader(s);
                        throw new Error('Shader compile failed: ' + log);
                    }
                    return s;
                }

                let prog;
                try {
                    prog = gl.createProgram();
                    gl.attachShader(prog, compile(gl.VERTEX_SHADER, VERT));
                    gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, FRAG));
                    gl.linkProgram(prog);
                    if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
                        throw new Error('Program link failed: ' + gl.getProgramInfoLog(prog));
                    }
                } catch (e) {
                    showErr('WebGL 着色器失败：' + e.message + '\n已切到 Canvas2D 备用渲染（无粘连）。');
                    return false;
                }

                gl.useProgram(prog);
                // 大三角
                const buf = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, buf);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 3, -1, -1, 3]), gl.STATIC_DRAW);
                const a_pos = gl.getAttribLocation(prog, 'a_pos');
                gl.enableVertexAttribArray(a_pos);
                gl.vertexAttribPointer(a_pos, 2, gl.FLOAT, false, 0, 0);

                // uniforms
                const u_res = gl.getUniformLocation(prog, 'u_res');
                const u_time = gl.getUniformLocation(prog, 'u_time');
                const u_half0 = gl.getUniformLocation(prog, 'u_half0');
                const u_radius4 = gl.getUniformLocation(prog, 'u_radius4');
                const u_step = gl.getUniformLocation(prog, 'u_step');
                const u_pulseMin = gl.getUniformLocation(prog, 'u_pulseMin');
                const u_pulseHz = gl.getUniformLocation(prog, 'u_pulseHz');
                const u_thresh = gl.getUniformLocation(prog, 'u_thresh');
                const u_falloff = gl.getUniformLocation(prog, 'u_falloff');
                const u_aa = gl.getUniformLocation(prog, 'u_aa');

                function syncStatics() {
                    gl.uniform2f(u_half0, (CFG.size * DPR) / 2, (CFG.size * DPR) / 2);
                    const r = CFG.corner * DPR;
                    // 顺序：TR, TL, BL, BR
                    gl.uniform4f(u_radius4, r, 0.0, r, 0.0);
                    gl.uniform1f(u_pulseMin, CFG.pulseMin);
                    gl.uniform1f(u_pulseHz, CFG.pulseSpeedHz);
                    gl.uniform1f(u_thresh, CFG.threshold);
                    gl.uniform1f(u_aa, CFG.aa * DPR);
                    const k = Math.log(2.0) / (Math.max(1e-3, CFG.connectRange) * DPR);
                    gl.uniform1f(u_falloff, k);
                    syncStep();
                }

                function syncStep() {
                    const s = CFG.size * DPR;
                    const stepX = s * 2.0 + CFG.extraGap * 2 * DPR; // 横：空一块 + extraGap
                    const stepY = s + CFG.extraGap * DPR; // 竖：只用 extraGap
                    gl.uniform2f(u_step, stepX, stepY);
                }

                function resize() {
                    const w = Math.floor(innerWidth * DPR),
                        h = Math.floor(innerHeight * DPR);
                    glCanvas.width = w;
                    glCanvas.height = h;
                    glCanvas.style.width = innerWidth + 'px';
                    glCanvas.style.height = innerHeight + 'px';
                    gl.viewport(0, 0, w, h);
                    gl.uniform2f(u_res, w, h);
                }
                addEventListener('resize', resize);

                // UI
                let pulseOn = true;
                const btn = document.getElementById('pulse');
                btn.onclick = () => {
                    pulseOn = !pulseOn;
                    btn.setAttribute('aria-pressed', pulseOn);
                    btn.textContent = `脉动：${pulseOn?'开':'关'} (P)`;
                };
                addEventListener('keydown', e => {
                    if (e.key === 'p' || e.key === 'P') btn.click();
                });

                const id = x => document.getElementById(x);
                const sizeR = id('sizeRange'),
                    gapR = id('gapRange'),
                    radR = id('radiusRange'),
                    spdR = id('speedRange'),
                    crR = id('crRange'),
                    thR = id('thRange');
                const vSize = id('vSize'),
                    vGap = id('vGap'),
                    vRad = id('vRadius'),
                    vSpd = id('vSpeed'),
                    vCR = id('vCR'),
                    vTh = id('vTh');

                function initSliders() {
                    sizeR.value = CFG.size;
                    vSize.textContent = CFG.size + ' px';
                    gapR.value = CFG.extraGap;
                    vGap.textContent = CFG.extraGap + ' px';
                    radR.value = CFG.corner;
                    vRad.textContent = CFG.corner + ' px';
                    spdR.value = CFG.pulseSpeedHz;
                    vSpd.textContent = CFG.pulseSpeedHz.toFixed(2) + ' Hz';
                    crR.value = CFG.connectRange;
                    vCR.textContent = CFG.connectRange.toFixed(1) + ' px';
                    thR.value = CFG.threshold;
                    vTh.textContent = CFG.threshold.toFixed(2);
                }
                sizeR.oninput = () => {
                    CFG.size = +sizeR.value;
                    vSize.textContent = CFG.size + ' px';
                    syncStatics();
                };
                gapR.oninput = () => {
                    CFG.extraGap = +gapR.value;
                    vGap.textContent = CFG.extraGap + ' px';
                    syncStep();
                };
                radR.oninput = () => {
                    CFG.corner = +radR.value;
                    vRad.textContent = CFG.corner + ' px';
                    syncStatics();
                };
                spdR.oninput = () => {
                    CFG.pulseSpeedHz = +spdR.value;
                    vSpd.textContent = CFG.pulseSpeedHz.toFixed(2) + ' Hz';
                    gl.uniform1f(u_pulseHz, CFG.pulseSpeedHz);
                };
                crR.oninput = () => {
                    CFG.connectRange = +crR.value;
                    vCR.textContent = CFG.connectRange.toFixed(1) + ' px';
                    const k = Math.log(2.0) / (Math.max(1e-3, CFG.connectRange) * DPR);
                    gl.uniform1f(u_falloff, k);
                };
                thR.oninput = () => {
                    CFG.threshold = +thR.value;
                    vTh.textContent = CFG.threshold.toFixed(2);
                    gl.uniform1f(u_thresh, CFG.threshold);
                };

                // 渲染
                let t0 = performance.now();

                function frame() {
                    gl.clearColor(0, 0, 0, 1);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    const t = (performance.now() - t0) * 0.001;
                    gl.uniform1f(u_time, pulseOn ? t : 0.0);
                    gl.drawArrays(gl.TRIANGLES, 0, 3);
                    requestAnimationFrame(frame);
                }
                resize();
                initSliders();
                syncStatics();
                frame();
                return true;
            }

            // ——— Canvas2D 备用（无粘连，仅让你至少看到格子） ———
            function startFallback() {
                const ctx = fbCanvas.getContext('2d');

                function resize() {
                    fbCanvas.width = innerWidth;
                    fbCanvas.height = innerHeight;
                }

                function rr(ctx, x, y, w, h, r) {
                    const m = Math.min(w, h) / 2;
                    r = Math.max(0, Math.min(r, m));
                    ctx.beginPath();
                    ctx.moveTo(x + r, y);
                    ctx.arcTo(x + w, y, x + w, y + h, r);
                    ctx.arcTo(x + w, y + h, x, y + h, r);
                    ctx.arcTo(x, y + h, x, y, r);
                    ctx.arcTo(x, y, x + w, y, r);
                    ctx.closePath();
                }

                function draw() {
                    ctx.clearRect(0, 0, fbCanvas.width, fbCanvas.height);
                    const s = CFG.size,
                        gap = CFG.extraGap,
                        stepX = s * 2 + gap,
                        stepY = s + gap;
                    const cx = fbCanvas.width / 2,
                        cy = fbCanvas.height / 2;
                    const t = (performance.now() * 0.001) * CFG.pulseSpeedHz * 2 * Math.PI;
                    const phase = 0.5 + 0.5 * Math.sin(t);
                    const k = CFG.pulseMin + (1 - CFG.pulseMin) * phase;
                    const half = s * 0.5 * k,
                        r = Math.min(CFG.corner * k, half - 1);
                    ctx.fillStyle = '#fff';
                    for (let j = -1000; j <= 1000; j++) {
                        const rowOff = (Math.abs(j) % 2) * 0.5;
                        const y = cy + j * stepY;
                        if (y < -s * 2 || y > fbCanvas.height + s * 2) continue;
                        for (let i = -1000; i <= 1000; i++) {
                            const x = cx + (i + rowOff) * stepX;
                            if (x < -s * 2 || x > fbCanvas.width + s * 2) continue;
                            rr(ctx, x - half, y - half, half * 2, half * 2, r);
                            ctx.fill();
                        }
                    }
                    requestAnimationFrame(draw);
                }
                addEventListener('resize', resize);
                resize();
                draw();
            }

            const ok = startWebGL();
            if (!ok) startFallback(); // 只有失败时才回退（无粘连）
        })();
    </script>
</body>

</html>