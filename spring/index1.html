<!doctype html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>四个可拖拽方形 · 靠近自动连接（修复Y轴与拖拽）</title>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            background: #0b0f14
        }

        canvas {
            position: fixed;
            inset: 0;
            display: block;
            width: 100%;
            height: 100%;
            touch-action: none;
            cursor: grab
        }

        .ui {
            position: fixed;
            left: 16px;
            top: 16px;
            display: flex;
            gap: 8px;
            z-index: 10
        }

        .btn {
            cursor: pointer;
            border: 1px solid #2a3340;
            background: #101825;
            color: #e6eefc;
            padding: 8px 12px;
            border-radius: 10px;
            font: 600 12px/1 ui-sans-serif, system-ui
        }

        .chip {
            user-select: none;
            border: 1px solid #2a3340;
            background: #0f141b;
            color: #cdd6f4;
            padding: 6px 10px;
            border-radius: 999px;
            font: 12px/1 ui-sans-serif, system-ui
        }
    </style>
</head>

<body>
    <canvas id="gl"></canvas>
    <div class="ui">
        <button id="reset" class="btn">重置布局 (R)</button>
        <span class="chip">拖拽方块可移动；靠近会自动连接</span>
    </div>

    <script>
        (() => {
            // —— 可调参数 ——————————————————————————————————————————
            const CFG = {
                size: 140, // 方块边长（CSS px）
                corner: 24, // 圆角半径（CSS px；设 0 为直角）
                connectRange: 34, // 连接感应距离（越大越容易远距离连）
                threshold: 1.0, // 连接阈值（越小越容易连）
                strokeAA: 1.0 // 边缘抗锯齿宽度
            };

            // —— WebGL 基础 ————————————————————————————————————————
            const canvas = document.getElementById('gl');
            const gl = canvas.getContext('webgl');
            if (!gl) {
                alert('需要 WebGL 支持');
                return;
            }
            const DPR = Math.min(2, window.devicePixelRatio || 1);

            const vertSrc = `
    attribute vec2 a_pos;
    void main() { gl_Position = vec4(a_pos, 0.0, 1.0); }
  `;

            // ★ 修复：把 y 轴翻转到“左上为原点”的像素坐标系
            const fragSrc = `
    precision highp float;
    uniform vec2  u_res;
    uniform vec2  u_center[4];
    uniform vec2  u_half[4];
    uniform float u_radius[4];
    uniform float u_falloff;
    uniform float u_thresh;
    uniform float u_aa;

    float sdRoundBox(vec2 p, vec2 b, float r){
      vec2 q = abs(p) - b;
      return length(max(q, 0.0)) - r;
    }

    void main(){
      // Flip Y: 让 uv.y 与鼠标/JS 同向（上小下大 → 上大下小）
      vec2 uv = vec2(gl_FragCoord.x, u_res.y - gl_FragCoord.y);

      float phi = 0.0;
      float dmin = 1e9;
      bool inside = false;

      for (int i=0;i<4;i++){
        vec2  c = u_center[i];
        vec2  b = u_half[i];
        float r = u_radius[i];

        float d = sdRoundBox(uv - c, b - vec2(r), r);
        dmin = min(dmin, d);
        if (d <= 0.0) inside = true;

        float outd = max(d, 0.0);
        phi += exp(-u_falloff * outd);
      }

      float mask = inside ? 1.0 : step(u_thresh, phi);
      float aa = clamp(1.0 - smoothstep(0.0, u_aa, dmin), 0.0, 1.0);
      mask = max(mask, aa * 0.95);

      gl_FragColor = vec4(vec3(mask), 1.0);
    }
  `;

            function compile(type, src) {
                const sh = gl.createShader(type);
                gl.shaderSource(sh, src);
                gl.compileShader(sh);
                if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) throw gl.getShaderInfoLog(sh);
                return sh;
            }
            const prog = gl.createProgram();
            gl.attachShader(prog, compile(gl.VERTEX_SHADER, vertSrc));
            gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, fragSrc));
            gl.linkProgram(prog);
            if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) throw gl.getProgramInfoLog(prog);
            gl.useProgram(prog);

            // 全屏三角形
            const quad = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, quad);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 3, -1, -1, 3]), gl.STATIC_DRAW);
            const a_pos = gl.getAttribLocation(prog, 'a_pos');
            gl.enableVertexAttribArray(a_pos);
            gl.vertexAttribPointer(a_pos, 2, gl.FLOAT, false, 0, 0);

            // uniforms
            const u_res = gl.getUniformLocation(prog, 'u_res');
            const u_center = gl.getUniformLocation(prog, 'u_center');
            const u_half = gl.getUniformLocation(prog, 'u_half');
            const u_radius = gl.getUniformLocation(prog, 'u_radius');
            const u_falloff = gl.getUniformLocation(prog, 'u_falloff');
            const u_thresh = gl.getUniformLocation(prog, 'u_thresh');
            const u_aa = gl.getUniformLocation(prog, 'u_aa');

            function resize() {
                const w = Math.floor(innerWidth * DPR);
                const h = Math.floor(innerHeight * DPR);
                canvas.width = w;
                canvas.height = h;
                canvas.style.width = innerWidth + 'px';
                canvas.style.height = innerHeight + 'px';
                gl.viewport(0, 0, w, h);
                gl.uniform2f(u_res, w, h);
                if (!boxes.length) resetLayout(); // 首次布局
            }
            window.addEventListener('resize', () => {
                resize();
                resetLayout(); // 如需保留位置，改成只 render() 不 reset
            });

            // 四个方块状态
            const boxes = []; // { c:[x,y] }
            function resetLayout() {
                boxes.length = 0;
                const W = canvas.width,
                    H = canvas.height;
                const s = CFG.size * DPR,
                    r = CFG.corner * DPR;
                const half = [s * 0.5, s * 0.5];
                const pos = [
                    [W * 0.33, H * 0.33],
                    [W * 0.67, H * 0.33],
                    [W * 0.33, H * 0.67],
                    [W * 0.67, H * 0.67]
                ];
                for (let i = 0; i < 4; i++) boxes.push({
                    c: pos[i].slice()
                });

                // 写固定尺寸（四个都相同）
                gl.uniform2fv(u_half, new Float32Array([half[0], half[1], half[0], half[1], half[0], half[1], half[
                    0], half[1]]));
                gl.uniform1fv(u_radius, new Float32Array([r, r, r, r]));
            }

            // 连接范围 → 衰减系数
            function updateParams() {
                const falloff = Math.log(2) / (CFG.connectRange * DPR); // gap=2*range 时，两块场强≈阈值
                gl.uniform1f(u_falloff, falloff);
                gl.uniform1f(u_thresh, CFG.threshold);
                gl.uniform1f(u_aa, CFG.strokeAA * DPR);
            }

            // 渲染
            function render() {
                // 更新中心
                const c = new Float32Array(8);
                for (let i = 0; i < 4; i++) {
                    c[i * 2] = boxes[i].c[0];
                    c[i * 2 + 1] = boxes[i].c[1];
                }
                gl.uniform2fv(u_center, c);

                gl.drawArrays(gl.TRIANGLES, 0, 3);
                requestAnimationFrame(render);
            }

            // —— 命中&拖拽（用 JS 同步的 SDF，顺手置顶） ————————————————
            function sdRoundBoxJS(px, py, cx, cy, halfx, halfy, r) {
                const qx = Math.abs(px - cx) - halfx;
                const qy = Math.abs(py - cy) - halfy;
                const ax = Math.max(qx, 0),
                    ay = Math.max(qy, 0);
                return Math.hypot(ax, ay) - r;
            }

            function hitIndex(x, y) {
                const s = CFG.size * DPR * 0.5,
                    r = CFG.corner * DPR;
                for (let i = boxes.length - 1; i >= 0; i--) {
                    const b = boxes[i];
                    if (sdRoundBoxJS(x, y, b.c[0], b.c[1], s - r, s - r, r) <= 0) return i;
                }
                return -1;
            }

            let dragging = -1,
                offx = 0,
                offy = 0;
            canvas.addEventListener('pointerdown', e => {
                const x = e.clientX * DPR,
                    y = e.clientY * DPR;
                const i = hitIndex(x, y);
                if (i >= 0) {
                    // ★ 被点中的块置顶，便于重叠时优先选择
                    const b = boxes.splice(i, 1)[0];
                    boxes.push(b);
                    dragging = boxes.length - 1;
                    offx = x - b.c[0];
                    offy = y - b.c[1];
                    canvas.setPointerCapture(e.pointerId);
                    canvas.style.cursor = 'grabbing';
                }
            });
            canvas.addEventListener('pointermove', e => {
                if (dragging < 0) return;
                const x = e.clientX * DPR,
                    y = e.clientY * DPR;
                const b = boxes[dragging];
                b.c[0] = x - offx;
                b.c[1] = y - offy; // 现在方向一致：向上拖 y 变小 → 图形也向上
            }, {
                passive: true
            });
            canvas.addEventListener('pointerup', e => {
                if (dragging >= 0) canvas.releasePointerCapture(e.pointerId);
                dragging = -1;
                canvas.style.cursor = 'grab';
            });
            window.addEventListener('keydown', e => {
                if (e.key === 'r' || e.key === 'R') resetLayout();
            });
            document.getElementById('reset').onclick = resetLayout;

            // 启动
            resize();
            updateParams();
            resetLayout();
            render();
        })();
    </script>
</body>

</html>