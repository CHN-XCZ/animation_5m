<!doctype html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>满屏粘连方块 + 每格弹簧回弹</title>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            background: #0b0f14
        }

        canvas {
            position: fixed;
            inset: 0;
            display: block;
            width: 100%;
            height: 100%
        }

        .ui {
            position: fixed;
            left: 16px;
            top: 16px;
            display: flex;
            gap: 8px;
            z-index: 10;
            flex-wrap: wrap;
            align-items: center;
            max-width: 96vw
        }

        .btn {
            cursor: pointer;
            border: 1px solid #2a3340;
            background: #101825;
            color: #e6eefc;
            padding: 8px 12px;
            border-radius: 10px;
            font: 600 12px/1 ui-sans-serif, system-ui
        }

        .btn[aria-pressed="true"] {
            background: #1b2a40;
            border-color: #314257
        }

        .panel {
            display: flex;
            gap: 12px;
            align-items: center;
            background: #0f141b;
            border: 1px solid #2a3340;
            padding: 8px 12px;
            border-radius: 12px
        }

        .panel label {
            font: 12px/1 ui-sans-serif, system-ui;
            color: #cdd6f4;
            opacity: .95
        }

        .panel input[type=range] {
            width: 140px
        }

        .val {
            min-width: 62px;
            display: inline-block;
            text-align: right;
            color: #e6eefc;
            font-weight: 600
        }

        .err {
            position: fixed;
            left: 16px;
            bottom: 16px;
            color: #ffebee;
            background: #3b1d22;
            border: 1px solid #6b2a36;
            border-radius: 8px;
            padding: 8px 10px;
            font: 12px/1.4 ui-sans-serif, system-ui;
            max-width: 70ch;
            white-space: pre-wrap;
            z-index: 10;
            display: none
        }
    </style>
</head>

<body>
    <canvas id="gl"></canvas>
    <canvas id="fallback" style="z-index:-1"></canvas>

    <div class="ui">
        <button id="pulse" class="btn" aria-pressed="true">脉动：开 (P)</button>
        <button id="pluck" class="btn" aria-pressed="true">拨动：开 (O)</button>

        <div class="panel">
            <label>尺寸 <span id="vSize" class="val"></span>
                <input id="sizeRange" type="range" min="8" max="160" step="1" />
            </label>
            <label>间隔 <span id="vGap" class="val"></span>
                <input id="gapRange" type="range" min="0" max="120" step="1" />
            </label>
            <label>圆角 <span id="vRadius" class="val"></span>
                <input id="radiusRange" type="range" min="0" max="80" step="1" />
            </label>
            <label>脉动速度 <span id="vSpeed" class="val"></span>
                <input id="speedRange" type="range" min="0" max="3" step="0.01" />
            </label>
            <label>连接范围 <span id="vCR" class="val"></span>
                <input id="crRange" type="range" min="0" max="12" step="0.1" />
            </label>
            <label>阈值 <span id="vTh" class="val"></span>
                <input id="thRange" type="range" min="0.1" max="4" step="0.01" />
            </label>
        </div>

        <div class="panel">
            <label>拨动强度上限 <span class="val">20</span></label>
            <label>速度→强度比例 <span id="vRatio" class="val"></span>
                <input id="ratioRange" type="range" min="0" max="0.1" step="0.001" />
            </label>
            <!-- 这两个现在用于“路径注入节奏”，而非延时反向 tap -->
            <label>释放延时(ms) <span id="vDelay" class="val"></span>
                <input id="delayRange" type="range" min="0" max="500" step="10" />
            </label>
        </div>

        <div class="panel">
            <label>拨动强度基准(amp) <span class="val">20</span></label>
            <label>空间衰减σ <span id="vSig" class="val"></span>
                <input id="sigRange" type="range" min="10" max="400" step="1" />
            </label>
            <label>波长λ <span id="vLam" class="val"></span>
                <input id="lamRange" type="range" min="20" max="800" step="1" />
            </label>
            <label>频率Hz <span id="vFq" class="val"></span>
                <input id="fqRange" type="range" min="0" max="5" step="0.01" />
            </label>
            <label>时间阻尼γ <span id="vGam" class="val"></span>
                <input id="gamRange" type="range" min="0" max="4" step="0.01" />
            </label>
        </div>

        <div class="panel">
            <button id="bindAmp" class="btn" aria-pressed="true">amp↔速：正比</button>
            <button id="bindSig" class="btn" aria-pressed="true">σ↔速：正比</button>
            <button id="bindLam" class="btn" aria-pressed="true">λ↔速：正比</button>
            <button id="bindFq" class="btn" aria-pressed="true">f↔速：正比</button>
            <button id="bindGam" class="btn" aria-pressed="true">γ↔速：正比</button>
            <label>速度上限(px/s) <span id="vSCap" class="val"></span>
                <input id="speedCapRange" type="range" min="200" max="4000" step="10" />
            </label>
            <label>映射强度 <span id="vSEff" class="val"></span>
                <input id="speedEffRange" type="range" min="0" max="2" step="0.01" />
            </label>
            <label>当前速度 <span id="vMS" class="val"></span></label>
        </div>

        <!-- 新增：弹簧参数（默认隐藏 UI，可直接用这组默认。需要可再加滑杆。） -->
        <div class="panel" style="display:none">
            <label>弹簧k</label><input id="kRange" type="range" min="5" max="200" step="1" />
            <label>阻尼c</label><input id="cRange" type="range" min="1" max="40" step="0.5" />
            <label>路径采样步数</label><input id="sampleRange" type="range" min="1" max="8" step="1" />
        </div>
    </div>

    <div id="err" class="err"></div>

    <script>
        (() => {
            // —— 你的显示参数（保留） ——
            const CFG = {
                size: 18,
                corner: 3,
                extraGap: 4,
                pulseSpeedHz: 0.3,
                pulseMin: 0.0,
                connectRange: 2.0,
                threshold: 1.0,
                aa: 1.0
            };

            // —— 这些 UI 仍保留（外观参数），位移改由弹簧系统产生 ——
            const WAVE = {
                amp: 20,
                sigma: 30,
                lambda: 68,
                freq: 1.2,
                gamma: 1.0
            };

            // —— 鼠标速度 → “注入强度”（作为速度脉冲的比例） ——
            const PLUCK = {
                ratio: 0.001,
                delayMs: 100,
                speedThreshold: 60
            };
            const AMP_CAP = 20;

            // —— 速度绑定显示（仍保留，不再驱动位移） ——
            const SPEEDBIND = {
                capPx: 1600,
                effect: 1.0,
                ampDir: true,
                sigDir: true,
                lamDir: true,
                fqDir: true,
                gamDir: true
            };

            // —— 弹簧参数 ——（可外露为 UI 滑杆）
            const SPRING = {
                k: 60.0, // 刚度（越大越快回）
                c: 8.0, // 阻尼（越大越粘）
                mass: 1.0, // 质量
                gainRatio: 0.02, // 鼠标速度(px/s) → 注入速度 的比例
                maxImpulse: 500.0, // 单次注入上限（像素/秒）
                samplesPerStep: 3 // 路径采样点（保证途经所有格子得到脉冲）
            };

            const DPR = Math.min(2, window.devicePixelRatio || 1);
            const glCanvas = document.getElementById('gl');
            const fbCanvas = document.getElementById('fallback');
            const errBox = document.getElementById('err');

            function showErr(msg) {
                errBox.style.display = 'block';
                errBox.textContent = msg;
                fbCanvas.style.zIndex = '1';
            }

            // ————————— WebGL —————————
            const gl = glCanvas.getContext('webgl', {
                antialias: false,
                alpha: false
            });
            if (!gl) {
                showErr('未启用 WebGL，已回退 Canvas2D。');
                startFallback();
                return;
            }
            if (!gl.getExtension('OES_texture_float')) {
                showErr('需要 WebGL 扩展：OES_texture_float');
                return;
            }

            const VERT = `
    #ifdef GL_ES
    precision highp float;
    #endif
    attribute vec2 a_pos;
    void main(){ gl_Position = vec4(a_pos,0.0,1.0); }`;

            const FRAG = `
    #ifdef GL_ES
      #ifdef GL_FRAGMENT_PRECISION_HIGH
        precision highp float;
      #else
        precision mediump float;
      #endif
    #else
      precision highp float;
    #endif

    uniform vec2  u_res;
    uniform float u_time;

    // 栅格/形状
    uniform vec2  u_half0;
    uniform vec4  u_radius4; // TR, TL, BL, BR
    uniform vec2  u_step;
    uniform float u_pulseMin, u_pulseHz;
    uniform float u_thresh, u_falloff, u_aa;

    // —— 新增：每格位移数据纹理 —— 
    uniform vec2  u_texSize;       // (cols, rows)
    uniform ivec2 u_gridMin;       // (iMin, jMin)
    uniform sampler2D u_dispTex;   // RG = (dx,dy)

    float sdRoundBoxCorners(vec2 p, vec2 b, vec4 r4){
      vec2 s = sign(p);
      float r = (s.x>0.0) ? ((s.y>0.0)? r4.x : r4.w)
                          : ((s.y>0.0)? r4.y : r4.z);
      r = clamp(r, 0.0, min(b.x,b.y)-1.0);
      vec2 q = abs(p) - (b - vec2(r));
      return length(max(q, vec2(0.0))) - r;
    }

    vec2 fetchDisp(ivec2 ij){
      ivec2 ij0 = ij - u_gridMin;
      vec2 uv = (vec2(ij0) + 0.5) / u_texSize;
      return texture2D(u_dispTex, uv).rg;
    }

    void main(){
      vec2 uv = gl_FragCoord.xy;
      vec2 C  = u_res * 0.5;

      float phase = 0.5 + 0.5 * sin(6.2831853 * u_pulseHz * u_time);
      float pulse = u_pulseMin + (1.0 - u_pulseMin) * phase;

      float dmin = 1e6;
      float insideF = 0.0;
      float phi = 0.0;

      float jBase = floor((uv.y - C.y) / u_step.y + 0.5);
      for(int jy=-1;jy<=1;jy++){
        float j = jBase + float(jy);
        float rowOff = mod(abs(j), 2.0) * 0.5;
        float iBase = floor((uv.x - C.x - rowOff*u_step.x) / u_step.x + 0.5);
        for(int ix=-1; ix<=1; ix++){
          float i = iBase + float(ix);

          vec2 center = vec2(C.x + (i + rowOff) * u_step.x,
                             C.y +  j            * u_step.y);

          // ★ 把该格的位移叠加到中心
          vec2 disp = fetchDisp(ivec2(int(i), int(j)));
          center += disp;

          vec2 hSize  = u_half0 * pulse;
          vec4 r4     = u_radius4 * pulse;
          float d     = sdRoundBoxCorners(uv - center, hSize, r4);

          dmin = min(dmin, d);
          if(d <= 0.0) insideF = 1.0;
          phi += exp(-u_falloff * max(d, 0.0));
        }
      }

      float mask = (insideF > 0.5) ? 1.0 : step(u_thresh, phi);
      float edge = clamp(1.0 - smoothstep(0.0, u_aa, dmin), 0.0, 1.0);
      mask = max(mask, edge * 0.95);
      gl_FragColor = vec4(vec3(mask), 1.0);
    }`;

            // —— 编译/链接 —— //
            function compile(type, src) {
                const s = gl.createShader(type);
                gl.shaderSource(s, src);
                gl.compileShader(s);
                if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
                    const log = gl.getShaderInfoLog(s) || '(empty log)';
                    gl.deleteShader(s);
                    throw new Error(log);
                }
                return s;
            }
            let prog;
            try {
                prog = gl.createProgram();
                gl.attachShader(prog, compile(gl.VERTEX_SHADER, VERT));
                gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, FRAG));
                gl.linkProgram(prog);
                if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
                    throw new Error(gl.getProgramInfoLog(prog));
                }
            } catch (e) {
                showErr('WebGL 着色器失败：' + e.message + '。已回退 Canvas2D。');
                startFallback();
                return;
            }
            gl.useProgram(prog);

            // 全屏大三角
            const buf = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buf);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 3, -1, -1, 3]), gl.STATIC_DRAW);
            const a_pos = gl.getAttribLocation(prog, 'a_pos');
            gl.enableVertexAttribArray(a_pos);
            gl.vertexAttribPointer(a_pos, 2, gl.FLOAT, false, 0, 0);

            // uniform 位置
            const U = n => gl.getUniformLocation(prog, n);
            const u_res = U('u_res'),
                u_time = U('u_time');
            const u_half0 = U('u_half0'),
                u_radius4 = U('u_radius4'),
                u_step = U('u_step');
            const u_pulseMin = U('u_pulseMin'),
                u_pulseHz = U('u_pulseHz');
            const u_thresh = U('u_thresh'),
                u_falloff = U('u_falloff'),
                u_aa = U('u_aa');

            // 数据纹理 uniforms
            const u_dispTex = U('u_dispTex');
            const u_texSize = U('u_texSize');
            const u_gridMin = U('u_gridMin');

            // 同步静态参数
            function syncStatics() {
                gl.uniform2f(u_half0, (CFG.size * DPR) / 2, (CFG.size * DPR) / 2);
                const r = CFG.corner * DPR;
                gl.uniform4f(u_radius4, r, 0.0, r, 0.0);
                gl.uniform1f(u_pulseMin, CFG.pulseMin);
                gl.uniform1f(u_pulseHz, CFG.pulseSpeedHz);
                gl.uniform1f(u_thresh, CFG.threshold);
                gl.uniform1f(u_aa, CFG.aa * DPR);
                const k = Math.log(2.0) / (Math.max(1e-3, CFG.connectRange) * DPR);
                gl.uniform1f(u_falloff, k);
                syncStep();
            }

            function syncStep() {
                const s = CFG.size * DPR;
                const stepX = s * 2.0 + CFG.extraGap * 2 * DPR;
                const stepY = s + CFG.extraGap * DPR;
                gl.uniform2f(u_step, stepX, stepY);
                initSpringField(); // ★ 步距变化时重建格场
                syncSpringUniforms();
            }

            function resize() {
                const w = Math.floor(innerWidth * DPR),
                    h = Math.floor(innerHeight * DPR);
                glCanvas.width = w;
                glCanvas.height = h;
                glCanvas.style.width = innerWidth + 'px';
                glCanvas.style.height = innerHeight + 'px';
                gl.viewport(0, 0, w, h);
                gl.uniform2f(u_res, w, h);
                initSpringField(); // ★ 分辨率变化时重建格场
                syncSpringUniforms();
            }
            addEventListener('resize', resize);

            // —— 每格弹簧场：位移/速度数组 + 数据纹理 —— //
            let cols = 0,
                rows = 0,
                iMin = 0,
                jMin = 0;
            let dispArray = null,
                velArray = null,
                dispTex = null;

            function gridMetrics() {
                const s = CFG.size * DPR;
                return {
                    stepX: s * 2.0 + CFG.extraGap * 2 * DPR,
                    stepY: s + CFG.extraGap * DPR
                };
            }

            function initSpringField() {
                const w = glCanvas.width,
                    h = glCanvas.height;
                const {
                    stepX,
                    stepY
                } = gridMetrics();
                // 估算覆盖范围（左右/上下各多给3格缓冲）
                const iSpan = Math.ceil((w / stepX) + 3),
                    jSpan = Math.ceil((h / stepY) + 3);
                iMin = -iSpan;
                jMin = -jSpan;
                const iMax = iSpan,
                    jMax = jSpan;
                cols = iMax - iMin + 1;
                rows = jMax - jMin + 1;

                dispArray = new Float32Array(cols * rows * 2);
                velArray = new Float32Array(cols * rows * 2);

                if (!dispTex) dispTex = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, dispTex);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, cols, rows, 0, gl.RGBA, gl.FLOAT, new Float32Array(cols *
                    rows * 4));
            }

            function syncSpringUniforms() {
                gl.uniform2f(u_texSize, cols, rows);
                gl.uniform2i(u_gridMin, iMin, jMin);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, dispTex);
                gl.uniform1i(u_dispTex, 0);
            }

            function idx(i, j) {
                const ii = i - iMin,
                    jj = j - jMin;
                if (ii < 0 || ii >= cols || jj < 0 || jj >= rows) return -1;
                return (jj * cols + ii) * 2;
            }

            function nearestIndex(x, y) {
                const w = glCanvas.width,
                    h = glCanvas.height;
                const Cx = w * 0.5,
                    Cy = h * 0.5;
                const {
                    stepX,
                    stepY
                } = gridMetrics();
                const j = Math.floor((y - Cy) / stepY + 0.5);
                const ro = (Math.abs(j) % 2) * 0.5;
                const i = Math.floor((x - Cx - ro * stepX) / stepX + 0.5);
                return {
                    i,
                    j
                };
            }

            // 每帧积分 + 上传纹理
            let lastTick = performance.now() * 0.001;

            function stepSprings() {
                const now = performance.now() * 0.001;
                let dt = now - lastTick;
                lastTick = now;
                dt = Math.min(dt, 1 / 30);
                const k = SPRING.k,
                    c = SPRING.c,
                    invM = 1.0 / SPRING.mass;

                for (let j = 0; j < rows; j++) {
                    for (let i = 0; i < cols; i++) {
                        const p = (j * cols + i) * 2;
                        let x = dispArray[p],
                            y = dispArray[p + 1];
                        let vx = velArray[p],
                            vy = velArray[p + 1];

                        const ax = (-k * x - c * vx) * invM;
                        const ay = (-k * y - c * vy) * invM;
                        vx += ax * dt;
                        vy += ay * dt;
                        x += vx * dt;
                        y += vy * dt;

                        dispArray[p] = x;
                        dispArray[p + 1] = y;
                        velArray[p] = vx;
                        velArray[p + 1] = vy;
                    }
                }

                // 写入纹理（RG=dx,dy；用 RGBA 兼容）
                const tex = new Float32Array(cols * rows * 4);
                for (let q = 0; q < cols * rows; q++) {
                    const p2 = q * 2,
                        p4 = q * 4;
                    tex[p4] = dispArray[p2];
                    tex[p4 + 1] = dispArray[p2 + 1];
                    tex[p4 + 2] = 0;
                    tex[p4 + 3] = 1;
                }
                gl.bindTexture(gl.TEXTURE_2D, dispTex);
                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, cols, rows, gl.RGBA, gl.FLOAT, tex);
            }

            // —— 鼠标注入：给路径上经过的所有格子速度脉冲 —— //
            let pluckOn = true,
                pulseOn = true;
            const btnPulse = document.getElementById('pulse');
            const btnPluck = document.getElementById('pluck');
            btnPulse.onclick = () => {
                pulseOn = !pulseOn;
                btnPulse.setAttribute('aria-pressed', pulseOn);
                btnPulse.textContent = `脉动：${pulseOn?'开':'关'} (P)`;
                gl.uniform1f(u_pulseHz, pulseOn ? CFG.pulseSpeedHz : 0.0);
            };
            btnPluck.onclick = () => {
                pluckOn = !pluckOn;
                btnPluck.setAttribute('aria-pressed', pluckOn);
                btnPluck.textContent = `拨动：${pluckOn?'开':'关'} (O)`;
            };
            addEventListener('keydown', e => {
                if (e.key === 'p' || e.key === 'P') btnPulse.click();
                if (e.key === 'o' || e.key === 'O') btnPluck.click();
            });

            const id = x => document.getElementById(x);
            const sizeR = id('sizeRange'),
                gapR = id('gapRange'),
                radR = id('radiusRange'),
                spdR = id('speedRange'),
                crR = id('crRange'),
                thR = id('thRange'),
                sigR = id('sigRange'),
                lamR = id('lamRange'),
                fqR = id('fqRange'),
                gamR = id('gamRange'),
                ratioR = id('ratioRange'),
                delayR = id('delayRange'),
                speedCapR = id('speedCapRange'),
                speedEffR = id('speedEffRange');
            const vSize = id('vSize'),
                vGap = id('vGap'),
                vRad = id('vRadius'),
                vSpd = id('vSpeed'),
                vCR = id('vCR'),
                vTh = id('vTh'),
                vSig = id('vSig'),
                vLam = id('vLam'),
                vFq = id('vFq'),
                vGam = id('vGam'),
                vRatio = id('vRatio'),
                vDelay = id('vDelay'),
                vSCap = id('vSCap'),
                vSEff = id('vSEff'),
                vMS = id('vMS');

            function initSliders() {
                sizeR.value = CFG.size;
                vSize.textContent = CFG.size + ' px';
                gapR.value = CFG.extraGap;
                vGap.textContent = CFG.extraGap + ' px';
                radR.value = CFG.corner;
                vRad.textContent = CFG.corner + ' px';
                spdR.value = CFG.pulseSpeedHz;
                vSpd.textContent = CFG.pulseSpeedHz.toFixed(2) + ' Hz';
                crR.value = CFG.connectRange;
                vCR.textContent = CFG.connectRange.toFixed(1) + ' px';
                thR.value = CFG.threshold;
                vTh.textContent = CFG.threshold.toFixed(2);
                sigR.value = WAVE.sigma;
                vSig.textContent = WAVE.sigma.toFixed(0) + ' px';
                lamR.value = WAVE.lambda;
                vLam.textContent = WAVE.lambda.toFixed(0) + ' px';
                fqR.value = WAVE.freq;
                vFq.textContent = WAVE.freq.toFixed(2) + ' Hz';
                gamR.value = WAVE.gamma;
                vGam.textContent = WAVE.gamma.toFixed(2);
                ratioR.value = PLUCK.ratio;
                vRatio.textContent = PLUCK.ratio.toFixed(3);
                delayR.value = PLUCK.delayMs;
                vDelay.textContent = PLUCK.delayMs + ' ms';
                speedCapR.value = SPEEDBIND.capPx;
                vSCap.textContent = SPEEDBIND.capPx + ' px/s';
                speedEffR.value = SPEEDBIND.effect;
                vSEff.textContent = SPEEDBIND.effect.toFixed(2);
                vMS.textContent = '0 px/s';
            }
            sizeR.oninput = () => {
                CFG.size = +sizeR.value;
                vSize.textContent = CFG.size + ' px';
                syncStatics();
            };
            gapR.oninput = () => {
                CFG.extraGap = +gapR.value;
                vGap.textContent = CFG.extraGap + ' px';
                syncStep();
            };
            radR.oninput = () => {
                CFG.corner = +radR.value;
                vRad.textContent = CFG.corner + ' px';
                syncStatics();
            };
            spdR.oninput = () => {
                CFG.pulseSpeedHz = +spdR.value;
                vSpd.textContent = CFG.pulseSpeedHz.toFixed(2) + ' Hz';
                gl.uniform1f(u_pulseHz, CFG.pulseSpeedHz);
            };
            crR.oninput = () => {
                CFG.connectRange = +crR.value;
                vCR.textContent = CFG.connectRange.toFixed(1) + ' px';
                gl.uniform1f(u_falloff, Math.log(2.0) / (Math.max(1e-3, CFG.connectRange) * DPR));
            };
            thR.oninput = () => {
                CFG.threshold = +thR.value;
                vTh.textContent = CFG.threshold.toFixed(2);
                gl.uniform1f(u_thresh, CFG.threshold);
            };
            sigR.oninput = () => {
                WAVE.sigma = +sigR.value;
                vSig.textContent = WAVE.sigma.toFixed(0) + ' px';
            };
            lamR.oninput = () => {
                WAVE.lambda = +lamR.value;
                vLam.textContent = WAVE.lambda.toFixed(0) + ' px';
            };
            fqR.oninput = () => {
                WAVE.freq = +fqR.value;
                vFq.textContent = WAVE.freq.toFixed(2) + ' Hz';
            };
            gamR.oninput = () => {
                WAVE.gamma = +gamR.value;
                vGam.textContent = WAVE.gamma.toFixed(2);
            };
            ratioR.oninput = () => {
                PLUCK.ratio = +ratioR.value;
                vRatio.textContent = PLUCK.ratio.toFixed(3);
            };
            delayR.oninput = () => {
                PLUCK.delayMs = +delayR.value;
                vDelay.textContent = PLUCK.delayMs + ' ms';
            };
            speedCapR.oninput = () => {
                SPEEDBIND.capPx = +speedCapR.value;
                vSCap.textContent = SPEEDBIND.capPx + ' px/s';
            };
            speedEffR.oninput = () => {
                SPEEDBIND.effect = +speedEffR.value;
                vSEff.textContent = SPEEDBIND.effect.toFixed(2);
            };

            function bindBtn(id, flagKey, label) {
                const el = document.getElementById(id);
                el.onclick = () => {
                    SPEEDBIND[flagKey] = !SPEEDBIND[flagKey];
                    el.setAttribute('aria-pressed', SPEEDBIND[flagKey]);
                    el.textContent = `${label}：${SPEEDBIND[flagKey]?'正比':'反比'}`;
                };
                el.textContent = `${label}：${SPEEDBIND[flagKey]?'正比':'反比'}`;
            }
            bindBtn('bindAmp', 'ampDir', 'amp↔速');
            bindBtn('bindSig', 'sigDir', 'σ↔速');
            bindBtn('bindLam', 'lamDir', 'λ↔速');
            bindBtn('bindFq', 'fqDir', 'f↔速');
            bindBtn('bindGam', 'gamDir', 'γ↔速');

            // 鼠标路径注入
            const mouse = {
                x: 0,
                y: 0,
                t: 0
            };
            let instSpeed = 0,
                smoothSpeed = 0;

            function injectPathImpulse(x0, y0, x1, y1, speed, vx, vy) {
                // 归一化方向
                const s = speed + 1e-6;
                const ux = vx / s,
                    uy = vy / s;
                const gain = Math.min(SPRING.maxImpulse, speed * SPRING.gainRatio);
                // 采样步数：保证路径上的格子都会被打到
                const steps = Math.max(1, SPRING.samplesPerStep * Math.max(
                    Math.abs(x1 - x0) / (CFG.size * DPR), Math.abs(y1 - y0) / (CFG.size * DPR)
                ));
                for (let k = 0; k <= steps; k++) {
                    const t = k / steps;
                    const x = x0 + (x1 - x0) * t;
                    const y = y0 + (y1 - y0) * t;
                    const {
                        i,
                        j
                    } = nearestIndex(x, y);
                    const p = idx(i, j);
                    if (p < 0) continue;
                    velArray[p] += ux * gain;
                    velArray[p + 1] += uy * gain;
                }
            }

            addEventListener('pointermove', e => {
                const rect = glCanvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) * DPR;
                const y = (rect.bottom - e.clientY) * DPR;
                const now = performance.now() * 0.001;
                const dt = Math.max(1e-3, now - (mouse.t || now));
                const vx = (x - (mouse.x || x)) / dt;
                const vy = (y - (mouse.y || y)) / dt;
                instSpeed = Math.hypot(vx, vy);
                smoothSpeed = 0.25 * instSpeed + 0.75 * smoothSpeed;
                vMS.textContent = Math.round(smoothSpeed) + ' px/s';

                if (pluckOn) {
                    // 给路径上所有经过的格子注入“速度脉冲” → 离开即各自回弹
                    if (instSpeed > PLUCK.speedThreshold || (now - (mouse.t || 0)) > 0.08) {
                        injectPathImpulse(mouse.x || x, mouse.y || y, x, y, instSpeed, vx, vy);
                    }
                }
                mouse.x = x;
                mouse.y = y;
                mouse.t = now;
            }, {
                passive: true
            });

            addEventListener('pointerdown', e => {
                const rect = glCanvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) * DPR;
                const y = (rect.bottom - e.clientY) * DPR;
                mouse.x = x;
                mouse.y = y;
                mouse.t = performance.now() * 0.001;
                // 点击时给当前格一个小脉冲，手感更“弹”
                const speed = 600; // 人工注入一个速度量级
                injectPathImpulse(x, y, x + 1, y, speed, 1, 0);
            }, {
                passive: true
            });

            // 渲染
            let t0 = performance.now();

            function frame() {
                stepSprings(); // ★ 先积分 → 上传位移纹理

                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                const t = (performance.now() - t0) * 0.001;
                gl.uniform1f(u_time, t);

                gl.drawArrays(gl.TRIANGLES, 0, 3);
                requestAnimationFrame(frame);
            }

            // 启动
            function boot() {
                resize();
                syncStatics();
                initSliders();
                frame();
            }
            boot();

            // ——— Canvas2D 备用（不含拨动/粘连） ———
            function startFallback() {
                const ctx = fbCanvas.getContext('2d');

                function resize2() {
                    fbCanvas.width = innerWidth;
                    fbCanvas.height = innerHeight;
                }

                function rr4(ctx, x, y, w, h, rTR, rTL, rBL, rBR) {
                    const rr = (v) => Math.max(0, Math.min(v, Math.min(w, h) / 2 - 0.5));
                    rTR = rr(rTR);
                    rTL = rr(rTL);
                    rBL = rr(rBL);
                    rBR = rr(rBR);
                    ctx.beginPath();
                    ctx.moveTo(x + rTL, y);
                    ctx.lineTo(x + w - rTR, y);
                    ctx.arcTo(x + w, y, x + w, y + rTR, rTR);
                    ctx.lineTo(x + w, y + h - rBR);
                    ctx.arcTo(x + w, y + h, x + w - rBR, y + h, rBR);
                    ctx.lineTo(x + rBL, y + h);
                    ctx.arcTo(x, y + h, x, y + h - rBL, rBL);
                    ctx.lineTo(x, y + rTL);
                    ctx.arcTo(x, y, x + rTL, y, rTL);
                    ctx.closePath();
                }

                function draw() {
                    ctx.clearRect(0, 0, fbCanvas.width, fbCanvas.height);
                    const s = CFG.size,
                        gap = CFG.extraGap;
                    const stepX = s * 2 + gap,
                        stepY = s + gap;
                    const cx = fbCanvas.width / 2,
                        cy = fbCanvas.height / 2;
                    const t = (performance.now() * 0.001) * CFG.pulseSpeedHz * 2 * Math.PI;
                    const k = CFG.pulseMin + (1 - CFG.pulseMin) * (0.5 + 0.5 * Math.sin(t));
                    const half = s * 0.5 * k,
                        r = Math.min(CFG.corner * k, half - 0.5);
                    ctx.fillStyle = '#fff';
                    for (let j = -1000; j <= 1000; j++) {
                        const rowOff = (Math.abs(j) % 2) * 0.5;
                        const y = cy + j * stepY;
                        if (y < -s * 2 || y > fbCanvas.height + s * 2) continue;
                        for (let i = -1000; i <= 1000; i++) {
                            const x = cx + (i + rowOff) * stepX;
                            if (x < -s * 2 || x > fbCanvas.width + s * 2) continue;
                            rr4(ctx, x - half, y - half, half * 2, half * 2, r, 0, r, 0);
                            ctx.fill();
                        }
                    }
                    requestAnimationFrame(draw);
                }
                addEventListener('resize', resize2);
                resize2();
                draw();
            }
        })();
    </script>
</body>

</html>