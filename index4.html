<!doctype html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>满屏粘连方块 + 速度驱动拨动 & 延时回弹</title>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            background: #0b0f14
        }

        canvas {
            position: fixed;
            inset: 0;
            display: block;
            width: 100%;
            height: 100%
        }

        .ui {
            position: fixed;
            left: 16px;
            top: 16px;
            display: flex;
            gap: 8px;
            z-index: 10;
            flex-wrap: wrap;
            align-items: center;
            max-width: 96vw
        }

        .btn {
            cursor: pointer;
            border: 1px solid #2a3340;
            background: #101825;
            color: #e6eefc;
            padding: 8px 12px;
            border-radius: 10px;
            font: 600 12px/1 ui-sans-serif, system-ui
        }

        .btn[aria-pressed="true"] {
            background: #1b2a40;
            border-color: #314257
        }

        .panel {
            display: flex;
            gap: 12px;
            align-items: center;
            background: #0f141b;
            border: 1px solid #2a3340;
            padding: 8px 12px;
            border-radius: 12px
        }

        .panel label {
            font: 12px/1 ui-sans-serif, system-ui;
            color: #cdd6f4;
            opacity: .95
        }

        .panel input[type=range] {
            width: 140px
        }

        .val {
            min-width: 62px;
            display: inline-block;
            text-align: right;
            color: #e6eefc;
            font-weight: 600
        }

        .err {
            position: fixed;
            left: 16px;
            bottom: 16px;
            color: #ffebee;
            background: #3b1d22;
            border: 1px solid #6b2a36;
            border-radius: 8px;
            padding: 8px 10px;
            font: 12px/1.4 ui-sans-serif, system-ui;
            max-width: 70ch;
            white-space: pre-wrap;
            z-index: 10;
            display: none
        }
    </style>
</head>

<body>
    <canvas id="gl"></canvas>
    <canvas id="fallback" style="z-index:-1"></canvas>

    <div class="ui">
        <button id="pulse" class="btn" aria-pressed="true">脉动：开 (P)</button>
        <button id="pluck" class="btn" aria-pressed="true">拨动：开 (O)</button>

        <div class="panel">
            <label>尺寸 <span id="vSize" class="val"></span>
                <input id="sizeRange" type="range" min="8" max="160" step="1" />
            </label>
            <label>间隔 <span id="vGap" class="val"></span>
                <input id="gapRange" type="range" min="0" max="120" step="1" />
            </label>
            <label>圆角 <span id="vRadius" class="val"></span>
                <input id="radiusRange" type="range" min="0" max="80" step="1" />
            </label>
            <label>脉动速度 <span id="vSpeed" class="val"></span>
                <input id="speedRange" type="range" min="0" max="3" step="0.01" />
            </label>
            <label>连接范围 <span id="vCR" class="val"></span>
                <input id="crRange" type="range" min="0" max="12" step="0.1" />
            </label>
            <label>阈值 <span id="vTh" class="val"></span>
                <input id="thRange" type="range" min="0.1" max="4" step="0.01" />
            </label>
        </div>

        <div class="panel">
            <label>拨动强度上限 <span class="val">20</span></label>
            <label>速度→强度比例 <span id="vRatio" class="val"></span>
                <input id="ratioRange" type="range" min="0" max="0.1" step="0.001" />
            </label>
            <label>释放延时(ms) <span id="vDelay" class="val"></span>
                <input id="delayRange" type="range" min="0" max="500" step="10" />
            </label>
        </div>

        <div class="panel">
            <label>拨动强度基准(amp) <span class="val">20</span></label>
            <label>空间衰减σ <span id="vSig" class="val"></span>
                <input id="sigRange" type="range" min="10" max="400" step="1" />
            </label>
            <label>波长λ <span id="vLam" class="val"></span>
                <input id="lamRange" type="range" min="20" max="800" step="1" />
            </label>
            <label>频率Hz <span id="vFq" class="val"></span>
                <input id="fqRange" type="range" min="0" max="5" step="0.01" />
            </label>
            <label>时间阻尼γ <span id="vGam" class="val"></span>
                <input id="gamRange" type="range" min="0" max="4" step="0.01" />
            </label>
        </div>

        <!-- 新增：速度绑定控制 -->
        <div class="panel">
            <button id="bindAmp" class="btn" aria-pressed="true">amp↔速：正比</button>
            <button id="bindSig" class="btn" aria-pressed="true">σ↔速：正比</button>
            <button id="bindLam" class="btn" aria-pressed="true">λ↔速：正比</button>
            <button id="bindFq" class="btn" aria-pressed="true">f↔速：正比</button>
            <button id="bindGam" class="btn" aria-pressed="true">γ↔速：正比</button>
            <label>速度上限(px/s) <span id="vSCap" class="val"></span>
                <input id="speedCapRange" type="range" min="200" max="4000" step="10" />
            </label>
            <label>映射强度 <span id="vSEff" class="val"></span>
                <input id="speedEffRange" type="range" min="0" max="2" step="0.01" />
            </label>
            <label>当前速度 <span id="vMS" class="val"></span></label>
        </div>
    </div>

    <div id="err" class="err"></div>

    <script>
        (() => {
            // —— 显示参数 ——（原样）
            const CFG = {
                size: 18,
                corner: 3,
                extraGap: 4,
                pulseSpeedHz: 0.3,
                pulseMin: 0.0,
                connectRange: 2.0,
                threshold: 1.0,
                aa: 1.0
            };

            // —— 拨动波（基准值，不随 UI 文案改变） ——
            const WAVE = {
                amp: 20,
                sigma: 30,
                lambda: 68,
                freq: 1.2,
                gamma: 1.0
            };

            // —— 鼠标速度 → 拨动强度 & 延时回弹 ——
            const PLUCK = {
                ratio: 0.001, // px/s → 振幅(像素)，强度 = clamp(speed*ratio, 0, AMP_CAP)
                delayMs: 100, // 离开栅格后的延时回弹
                speedThreshold: 60 // 低速抖动门槛
            };
            // 拨动强度上限：与 UI 文案保持一致，固定 20，避免与动态 amp 混淆
            const AMP_CAP = 20;

            // —— 速度绑定参数（新增） ——
            const SPEEDBIND = {
                capPx: 1600, // 速度归一化上限（px/s）
                effect: 1.0, // 映射强度，系数 g = 1 + s*effect
                ampDir: true, // true=正比, false=反比
                sigDir: true,
                lamDir: true,
                fqDir: true,
                gamDir: true
            };

            const DPR = Math.min(2, window.devicePixelRatio || 1);
            const glCanvas = document.getElementById('gl');
            const fbCanvas = document.getElementById('fallback');
            const errBox = document.getElementById('err');

            function showErr(msg) {
                errBox.style.display = 'block';
                errBox.textContent = msg;
                fbCanvas.style.zIndex = '1';
            }

            // ————————— WebGL —————————
            const gl = glCanvas.getContext('webgl', {
                antialias: false,
                alpha: false
            });
            if (!gl) {
                showErr('未启用 WebGL，已回退 Canvas2D。');
                startFallback();
                return;
            }

            const VERT = `
    #ifdef GL_ES
    precision highp float;
    #endif
    attribute vec2 a_pos;
    void main(){ gl_Position = vec4(a_pos,0.0,1.0); }`;

            // 提高 tap 缓冲，防止“未来回弹”尚未触发就被覆盖
            const MAX_TAPS = 24;

            const FRAG = `
    #ifdef GL_ES
      #ifdef GL_FRAGMENT_PRECISION_HIGH
        precision highp float;
      #else
        precision mediump float;
      #endif
    #else
      precision highp float;
    #endif

    uniform vec2  u_res;
    uniform float u_time;

    // 栅格/形状
    uniform vec2  u_half0;
    uniform vec4  u_radius4; // TR, TL, BL, BR
    uniform vec2  u_step;
    uniform float u_pulseMin, u_pulseHz;
    uniform float u_thresh, u_falloff, u_aa;

    // 拨动（动态注入）
    uniform float u_amp, u_sigma, u_lambda, u_freq, u_gamma;

    uniform float u_tapCount;
    uniform vec4  u_taps[${MAX_TAPS}];     // (x,y,t0,angle)
    uniform float u_tapGain[${MAX_TAPS}];  // 0..1

    float sdRoundBoxCorners(vec2 p, vec2 b, vec4 r4){
      vec2 s = sign(p);
      float r = (s.x>0.0) ? ((s.y>0.0)? r4.x : r4.w)
                          : ((s.y>0.0)? r4.y : r4.z);
      r = clamp(r, 0.0, min(b.x,b.y)-1.0);
      vec2 q = abs(p) - (b - vec2(r));
      return length(max(q, vec2(0.0))) - r;
    }

    vec2 waveDisplacement(vec2 p){
      vec2 disp = vec2(0.0);
      for(int i=0;i<${MAX_TAPS};i++){
        float mask = step(float(i), u_tapCount);
        vec4 tp = u_taps[i];
        vec2 toP = p - tp.xy;
        float r   = length(toP) + 1e-3;
        float age = max(0.0, u_time - tp.z);

        float env   = exp(-u_gamma*age) * exp(-r/u_sigma);
        float phase = 6.2831853 * u_freq * age - r / u_lambda;
        vec2  dir   = vec2(cos(tp.w), sin(tp.w));

        float a = (u_amp * u_tapGain[i]) * env * cos(phase) * mask;
        disp += dir * a;
      }
      return disp;
    }

    void main(){
      vec2 uv = gl_FragCoord.xy;
      vec2 C  = u_res * 0.5;

      vec2 uv2 = uv - waveDisplacement(uv);

      float phase = 0.5 + 0.5 * sin(6.2831853 * u_pulseHz * u_time);
      float pulse = u_pulseMin + (1.0 - u_pulseMin) * phase;

      float dmin = 1e6;
      float insideF = 0.0;
      float phi = 0.0;

      float jBase = floor((uv2.y - C.y) / u_step.y + 0.5);
      for(int jy=-1;jy<=1;jy++){
        float j = jBase + float(jy);
        float rowOff = mod(abs(j), 2.0) * 0.5;
        float iBase = floor((uv2.x - C.x - rowOff*u_step.x) / u_step.x + 0.5);
        for(int ix=-1; ix<=1; ix++){
          float i = iBase + float(ix);
          vec2 center = vec2(C.x + (i + rowOff) * u_step.x,
                             C.y +  j            * u_step.y);

          vec2 hSize  = u_half0 * pulse;
          vec4 r4     = u_radius4 * pulse;
          float d     = sdRoundBoxCorners(uv2 - center, hSize, r4);

          dmin = min(dmin, d);
          if(d <= 0.0) insideF = 1.0;
          phi += exp(-u_falloff * max(d, 0.0));
        }
      }

      float mask = (insideF > 0.5) ? 1.0 : step(u_thresh, phi);
      float edge = clamp(1.0 - smoothstep(0.0, u_aa, dmin), 0.0, 1.0);
      mask = max(mask, edge * 0.95);
      gl_FragColor = vec4(vec3(mask), 1.0);
    }`;

            // —— 编译/链接 —— //
            function compile(type, src) {
                const s = gl.createShader(type);
                gl.shaderSource(s, src);
                gl.compileShader(s);
                if (!gl.getShaderParameter(s, gl.COMPLETE_STATUS) && !gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
                    const log = gl.getShaderInfoLog(s) || '(empty log)';
                    gl.deleteShader(s);
                    throw new Error(log);
                }
                return s;
            }
            let prog;
            try {
                prog = gl.createProgram();
                gl.attachShader(prog, compile(gl.VERTEX_SHADER, VERT));
                gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, FRAG));
                gl.linkProgram(prog);
                if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
                    throw new Error(gl.getProgramInfoLog(prog));
                }
            } catch (e) {
                showErr('WebGL 着色器失败：' + e.message + '。已回退 Canvas2D。');
                startFallback();
                return;
            }
            gl.useProgram(prog);

            // 全屏大三角
            const buf = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buf);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 3, -1, -1, 3]), gl.STATIC_DRAW);
            const a_pos = gl.getAttribLocation(prog, 'a_pos');
            gl.enableVertexAttribArray(a_pos);
            gl.vertexAttribPointer(a_pos, 2, gl.FLOAT, false, 0, 0);

            // uniform 位置
            const U = n => gl.getUniformLocation(prog, n);
            const u_res = U('u_res'),
                u_time = U('u_time');
            const u_half0 = U('u_half0'),
                u_radius4 = U('u_radius4'),
                u_step = U('u_step');
            const u_pulseMin = U('u_pulseMin'),
                u_pulseHz = U('u_pulseHz');
            const u_thresh = U('u_thresh'),
                u_falloff = U('u_falloff'),
                u_aa = U('u_aa');

            const u_amp = U('u_amp'),
                u_sigma = U('u_sigma'),
                u_lambda = U('u_lambda'),
                u_freq = U('u_freq'),
                u_gamma = U('u_gamma');

            const u_tapCount = U('u_tapCount');
            const u_tapEls = [],
                u_gainEls = [];
            for (let i = 0; i < MAX_TAPS; i++) {
                u_tapEls.push(U(`u_taps[${i}]`));
                u_gainEls.push(U(`u_tapGain[${i}]`));
            }

            // 同步静态参数
            function syncStatics() {
                gl.uniform2f(u_half0, (CFG.size * DPR) / 2, (CFG.size * DPR) / 2);
                const r = CFG.corner * DPR;
                gl.uniform4f(u_radius4, r, 0.0, r, 0.0); // 右上/左下圆角
                gl.uniform1f(u_pulseMin, CFG.pulseMin);
                gl.uniform1f(u_pulseHz, CFG.pulseSpeedHz);
                gl.uniform1f(u_thresh, CFG.threshold);
                gl.uniform1f(u_aa, CFG.aa * DPR);
                const k = Math.log(2.0) / (Math.max(1e-3, CFG.connectRange) * DPR);
                gl.uniform1f(u_falloff, k);
                syncStep();
                // 波参数动态在 frame() 里更新，这里只设一次基准无所谓
                gl.uniform1f(u_amp, WAVE.amp);
                gl.uniform1f(u_sigma, WAVE.sigma * DPR);
                gl.uniform1f(u_lambda, WAVE.lambda * DPR);
                gl.uniform1f(u_freq, WAVE.freq);
                gl.uniform1f(u_gamma, WAVE.gamma);
            }

            function syncStep() {
                const s = CFG.size * DPR;
                const stepX = s * 2.0 + CFG.extraGap * 2 * DPR;
                const stepY = s + CFG.extraGap * DPR;
                gl.uniform2f(u_step, stepX, stepY);
            }

            function resize() {
                const w = Math.floor(innerWidth * DPR),
                    h = Math.floor(innerHeight * DPR);
                glCanvas.width = w;
                glCanvas.height = h;
                glCanvas.style.width = innerWidth + 'px';
                glCanvas.style.height = innerHeight + 'px';
                gl.viewport(0, 0, w, h);
                gl.uniform2f(u_res, w, h);
            }
            addEventListener('resize', resize);

            // ——— 鼠标 → tap（带 gain）+ 每个跨过的格心都安排延时回弹 ———
            const taps = new Float32Array(MAX_TAPS * 4); // (x,y,t0,angle)
            const gains = new Float32Array(MAX_TAPS); // 0..1
            let tapCount = 0,
                tapPtr = 0;

            function uploadTaps() {
                const n = Math.min(tapCount, MAX_TAPS);
                gl.uniform1f(u_tapCount, n);
                for (let i = 0; i < MAX_TAPS; i++) {
                    const loc = u_tapEls[i],
                        gloc = u_gainEls[i];
                    if (i < n) {
                        const j = i * 4;
                        gl.uniform4f(loc, taps[j], taps[j + 1], taps[j + 2], taps[j + 3]);
                        gl.uniform1f(gloc, gains[i]);
                    } else {
                        gl.uniform4f(loc, 0, 0, 0, 0);
                        gl.uniform1f(gloc, 0);
                    }
                }
            }

            function pushTap(x, y, angle, t0, gain01) {
                taps[tapPtr * 4 + 0] = x;
                taps[tapPtr * 4 + 1] = y;
                taps[tapPtr * 4 + 2] = t0;
                taps[tapPtr * 4 + 3] = angle;
                gains[tapPtr] = Math.max(0, Math.min(1, gain01 || 0));
                tapPtr = (tapPtr + 1) % MAX_TAPS;
                tapCount = Math.min(tapCount + 1, MAX_TAPS);
                uploadTaps();
            }

            function gridStep() {
                const s = CFG.size * DPR;
                return {
                    stepX: s * 2.0 + CFG.extraGap * 2 * DPR,
                    stepY: s + CFG.extraGap * DPR
                };
            }

            function nearestCell(x, y) {
                const w = glCanvas.width,
                    h = glCanvas.height;
                const Cx = w * 0.5,
                    Cy = h * 0.5;
                const {
                    stepX,
                    stepY
                } = gridStep();
                const j = Math.floor((y - Cy) / stepY + 0.5);
                const ro = (Math.abs(j) % 2) * 0.5;
                const i = Math.floor((x - Cx - ro * stepX) / stepX + 0.5);
                const cx = Cx + (i + ro) * stepX,
                    cy = Cy + j * stepY;
                return {
                    i,
                    j,
                    cx,
                    cy
                };
            }

            let pluckOn = true,
                pulseOn = true;
            const btnPulse = document.getElementById('pulse');
            const btnPluck = document.getElementById('pluck');
            btnPulse.onclick = () => {
                pulseOn = !pulseOn;
                btnPulse.setAttribute('aria-pressed', pulseOn);
                btnPulse.textContent = `脉动：${pulseOn?'开':'关'} (P)`;
                gl.uniform1f(u_pulseHz, pulseOn ? CFG.pulseSpeedHz : 0.0);
            };
            btnPluck.onclick = () => {
                pluckOn = !pluckOn;
                btnPluck.setAttribute('aria-pressed', pluckOn);
                btnPluck.textContent = `拨动：${pluckOn?'开':'关'} (O)`;
            };
            addEventListener('keydown', e => {
                if (e.key === 'p' || e.key === 'P') btnPulse.click();
                if (e.key === 'o' || e.key === 'O') btnPluck.click();
            });

            // 滑杆/显示
            const id = x => document.getElementById(x);
            const sizeR = id('sizeRange'),
                gapR = id('gapRange'),
                radR = id('radiusRange'),
                spdR = id('speedRange'),
                crR = id('crRange'),
                thR = id('thRange'),
                sigR = id('sigRange'),
                lamR = id('lamRange'),
                fqR = id('fqRange'),
                gamR = id('gamRange'),
                ratioR = id('ratioRange'),
                delayR = id('delayRange'),
                speedCapR = id('speedCapRange'),
                speedEffR = id('speedEffRange');

            const vSize = id('vSize'),
                vGap = id('vGap'),
                vRad = id('vRadius'),
                vSpd = id('vSpeed'),
                vCR = id('vCR'),
                vTh = id('vTh'),
                vSig = id('vSig'),
                vLam = id('vLam'),
                vFq = id('vFq'),
                vGam = id('vGam'),
                vRatio = id('vRatio'),
                vDelay = id('vDelay'),
                vSCap = id('vSCap'),
                vSEff = id('vSEff'),
                vMS = id('vMS');

            function initSliders() {
                sizeR.value = CFG.size;
                vSize.textContent = CFG.size + ' px';
                gapR.value = CFG.extraGap;
                vGap.textContent = CFG.extraGap + ' px';
                radR.value = CFG.corner;
                vRad.textContent = CFG.corner + ' px';
                spdR.value = CFG.pulseSpeedHz;
                vSpd.textContent = CFG.pulseSpeedHz.toFixed(2) + ' Hz';
                crR.value = CFG.connectRange;
                vCR.textContent = CFG.connectRange.toFixed(1) + ' px';
                thR.value = CFG.threshold;
                vTh.textContent = CFG.threshold.toFixed(2);

                sigR.value = WAVE.sigma;
                vSig.textContent = WAVE.sigma.toFixed(0) + ' px';
                lamR.value = WAVE.lambda;
                vLam.textContent = WAVE.lambda.toFixed(0) + ' px';
                fqR.value = WAVE.freq;
                vFq.textContent = WAVE.freq.toFixed(2) + ' Hz';
                gamR.value = WAVE.gamma;
                vGam.textContent = WAVE.gamma.toFixed(2);

                ratioR.value = PLUCK.ratio;
                vRatio.textContent = PLUCK.ratio.toFixed(3);
                delayR.value = PLUCK.delayMs;
                vDelay.textContent = PLUCK.delayMs + ' ms';

                speedCapR.value = SPEEDBIND.capPx;
                vSCap.textContent = SPEEDBIND.capPx + ' px/s';
                speedEffR.value = SPEEDBIND.effect;
                vSEff.textContent = SPEEDBIND.effect.toFixed(2);
                vMS.textContent = '0 px/s';
            }
            sizeR.oninput = () => {
                CFG.size = +sizeR.value;
                vSize.textContent = CFG.size + ' px';
                syncStatics();
            };
            gapR.oninput = () => {
                CFG.extraGap = +gapR.value;
                vGap.textContent = CFG.extraGap + ' px';
                syncStep();
            };
            radR.oninput = () => {
                CFG.corner = +radR.value;
                vRad.textContent = CFG.corner + ' px';
                syncStatics();
            };
            spdR.oninput = () => {
                CFG.pulseSpeedHz = +spdR.value;
                vSpd.textContent = CFG.pulseSpeedHz.toFixed(2) + ' Hz';
                gl.uniform1f(u_pulseHz, CFG.pulseSpeedHz);
            };
            crR.oninput = () => {
                CFG.connectRange = +crR.value;
                vCR.textContent = CFG.connectRange.toFixed(1) + ' px';
                gl.uniform1f(u_falloff, Math.log(2.0) / (Math.max(1e-3, CFG.connectRange) * DPR));
            };
            thR.oninput = () => {
                CFG.threshold = +thR.value;
                vTh.textContent = CFG.threshold.toFixed(2);
                gl.uniform1f(u_thresh, CFG.threshold);
            };

            sigR.oninput = () => {
                WAVE.sigma = +sigR.value;
                vSig.textContent = WAVE.sigma.toFixed(0) + ' px'; /* 动态更新放在 frame() */
            };
            lamR.oninput = () => {
                WAVE.lambda = +lamR.value;
                vLam.textContent = WAVE.lambda.toFixed(0) + ' px';
            };
            fqR.oninput = () => {
                WAVE.freq = +fqR.value;
                vFq.textContent = WAVE.freq.toFixed(2) + ' Hz';
            };
            gamR.oninput = () => {
                WAVE.gamma = +gamR.value;
                vGam.textContent = WAVE.gamma.toFixed(2);
            };

            ratioR.oninput = () => {
                PLUCK.ratio = +ratioR.value;
                vRatio.textContent = PLUCK.ratio.toFixed(3);
            };
            delayR.oninput = () => {
                PLUCK.delayMs = +delayR.value;
                vDelay.textContent = PLUCK.delayMs + ' ms';
            };

            speedCapR.oninput = () => {
                SPEEDBIND.capPx = +speedCapR.value;
                vSCap.textContent = SPEEDBIND.capPx + ' px/s';
            };
            speedEffR.oninput = () => {
                SPEEDBIND.effect = +speedEffR.value;
                vSEff.textContent = SPEEDBIND.effect.toFixed(2);
            };

            // 速度绑定开关
            function bindBtn(id, flagKey, label) {
                const el = document.getElementById(id);
                el.onclick = () => {
                    SPEEDBIND[flagKey] = !SPEEDBIND[flagKey];
                    el.setAttribute('aria-pressed', SPEEDBIND[flagKey]);
                    el.textContent = `${label}：${SPEEDBIND[flagKey] ? '正比' : '反比'}`;
                };
                // 初始文案
                el.textContent = `${label}：${SPEEDBIND[flagKey] ? '正比' : '反比'}`;
            }
            bindBtn('bindAmp', 'ampDir', 'amp↔速');
            bindBtn('bindSig', 'sigDir', 'σ↔速');
            bindBtn('bindLam', 'lamDir', 'λ↔速');
            bindBtn('bindFq', 'fqDir', 'f↔速');
            bindBtn('bindGam', 'gamDir', 'γ↔速');

            // 鼠标状态
            const mouse = {
                prevX: 0,
                prevY: 0,
                tPrev: 0
            };
            let lastTapTime = 0;
            let lastCell = null; // {i,j,cx,cy}
            let lastGain01 = 0;
            let lastAngle = 0;
            let instSpeed = 0; // 即时速度 px/s
            let smoothSpeed = 0; // 平滑速度用于 UI 与映射

            addEventListener('pointermove', e => {
                const rect = glCanvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) * DPR;
                const y = (rect.bottom - e.clientY) * DPR; // 自下向上
                const now = performance.now() * 0.001;
                const dt = Math.max(1e-3, now - mouse.tPrev);
                const vx = (x - mouse.prevX) / dt,
                    vy = (y - mouse.prevY) / dt;
                instSpeed = Math.hypot(vx, vy);

                // 平滑一下速度显示/映射（避免抖动）
                const alpha = 0.25;
                smoothSpeed = alpha * instSpeed + (1 - alpha) * smoothSpeed;
                vMS.textContent = Math.round(smoothSpeed) + ' px/s';

                const cell = nearestCell(x, y);

                if (pluckOn) {
                    // 速度→强度（px），上限 AMP_CAP(=20)
                    const ampPx = Math.min(AMP_CAP, instSpeed * PLUCK.ratio);
                    const gain01 = ampPx / AMP_CAP;
                    const angle = Math.atan2(vy, vx);

                    // 节流：给低速也留一点响应，同时不刷爆
                    if (instSpeed > PLUCK.speedThreshold || (now - lastTapTime) > 0.08) {
                        pushTap(x, y, angle, now, gain01);
                        lastTapTime = now;
                        lastGain01 = gain01;
                        lastAngle = angle;
                    }

                    // 跨格：为“刚离开的格心”安排延时回弹（不等停下）
                    if (lastCell && (cell.i !== lastCell.i || cell.j !== lastCell.j)) {
                        const delaySec = PLUCK.delayMs / 1000;
                        const reverseAngle = lastAngle + Math.PI;
                        pushTap(lastCell.cx, lastCell.cy, reverseAngle, now + delaySec, lastGain01);
                    }
                    lastCell = cell;
                }

                mouse.prevX = x;
                mouse.prevY = y;
                mouse.tPrev = now;
            }, {
                passive: true
            });

            addEventListener('pointerdown', e => {
                const rect = glCanvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) * DPR;
                const y = (rect.bottom - e.clientY) * DPR;
                const now = performance.now() * 0.001;
                pushTap(x, y, 0.0, now, 0.5);
                lastTapTime = now;
                lastCell = nearestCell(x, y);
                lastGain01 = 0.5;
                lastAngle = 0.0;
            }, {
                passive: true
            });

            // —— 速度绑定映射（每帧动态更新到 shader） ——
            function mapBySpeed(base, dir) {
                // s ∈ [0,1]
                const s = Math.max(0, Math.min(1, smoothSpeed / Math.max(1, SPEEDBIND.capPx)));
                const g = 1 + s * SPEEDBIND.effect; // 放大系数
                return dir ? (base * g) : (base / g);
            }

            // 渲染
            let t0 = performance.now();

            function frame() {
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);

                const t = (performance.now() - t0) * 0.001;
                gl.uniform1f(u_time, t);

                // 动态把 WAVE 注入（与鼠标速度绑定）
                const ampEff = mapBySpeed(WAVE.amp, SPEEDBIND.ampDir);
                const sigEff = mapBySpeed(WAVE.sigma, SPEEDBIND.sigDir) * DPR;
                const lamEff = mapBySpeed(WAVE.lambda, SPEEDBIND.lamDir) * DPR;
                const fqEff = mapBySpeed(WAVE.freq, SPEEDBIND.fqDir);
                const gamEff = mapBySpeed(WAVE.gamma, SPEEDBIND.gamDir);

                gl.uniform1f(u_amp, ampEff);
                gl.uniform1f(u_sigma, sigEff);
                gl.uniform1f(u_lambda, lamEff);
                gl.uniform1f(u_freq, fqEff);
                gl.uniform1f(u_gamma, gamEff);

                gl.drawArrays(gl.TRIANGLES, 0, 3);
                requestAnimationFrame(frame);
            }

            // 启动
            resize();
            syncStatics();
            initSliders();
            frame();

            // ——— Canvas2D 备用（不含拨动/粘连） ———
            function startFallback() {
                const ctx = fbCanvas.getContext('2d');

                function resize2() {
                    fbCanvas.width = innerWidth;
                    fbCanvas.height = innerHeight;
                }

                function rr4(ctx, x, y, w, h, rTR, rTL, rBL, rBR) {
                    const rr = (v) => Math.max(0, Math.min(v, Math.min(w, h) / 2 - 0.5));
                    rTR = rr(rTR);
                    rTL = rr(rTL);
                    rBL = rr(rBL);
                    rBR = rr(rBR);
                    ctx.beginPath();
                    ctx.moveTo(x + rTL, y);
                    ctx.lineTo(x + w - rTR, y);
                    ctx.arcTo(x + w, y, x + w, y + rTR, rTR);
                    ctx.lineTo(x + w, y + h - rBR);
                    ctx.arcTo(x + w, y + h, x + w - rBR, y + h, rBR);
                    ctx.lineTo(x + rBL, y + h);
                    ctx.arcTo(x, y + h, x, y + h - rBL, rBL);
                    ctx.lineTo(x, y + rTL);
                    ctx.arcTo(x, y, x + rTL, y, rTL);
                    ctx.closePath();
                }

                function draw() {
                    ctx.clearRect(0, 0, fbCanvas.width, fbCanvas.height);
                    const s = CFG.size,
                        gap = CFG.extraGap;
                    const stepX = s * 2 + gap,
                        stepY = s + gap;
                    const cx = fbCanvas.width / 2,
                        cy = fbCanvas.height / 2;
                    const t = (performance.now() * 0.001) * CFG.pulseSpeedHz * 2 * Math.PI;
                    const k = CFG.pulseMin + (1 - CFG.pulseMin) * (0.5 + 0.5 * Math.sin(t));
                    const half = s * 0.5 * k,
                        r = Math.min(CFG.corner * k, half - 0.5);
                    ctx.fillStyle = '#fff';
                    for (let j = -1000; j <= 1000; j++) {
                        const rowOff = (Math.abs(j) % 2) * 0.5;
                        const y = cy + j * stepY;
                        if (y < -s * 2 || y > fbCanvas.height + s * 2) continue;
                        for (let i = -1000; i <= 1000; i++) {
                            const x = cx + (i + rowOff) * stepX;
                            if (x < -s * 2 || x > fbCanvas.width + s * 2) continue;
                            rr4(ctx, x - half, y - half, half * 2, half * 2, r, 0, r, 0);
                            ctx.fill();
                        }
                    }
                    requestAnimationFrame(draw);
                }
                addEventListener('resize', resize2);
                resize2();
                draw();
            }
        })();
    </script>
</body>

</html>