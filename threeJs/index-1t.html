<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>满屏粘连方块 · three.js 版（生成即回弹·无尾巴）</title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        background: #0b0f14;
      }
      #glcanvas {
        position: fixed;
        inset: 0;
        display: block;
        width: 100%;
        height: 100%;
      }
      .ui {
        position: fixed;
        left: 16px;
        top: 16px;
        bottom: 16px;
        width: max(260px, 22vw);
        display: flex;
        flex-direction: column;
        gap: 12px;
        z-index: 10;
        background: #0f141b;
        border: 1px solid #2a3340;
        border-radius: 12px;
        padding: 12px;
        overflow: auto;
      }
      .row {
        display: flex;
        flex-direction: column;
        gap: 6px;
      }
      .h {
        margin: 0;
        font: 700 12px/1 ui-sans-serif, system-ui;
        color: #cdd6f4;
        opacity: 0.8;
      }
      .label {
        display: flex;
        justify-content: space-between;
        align-items: center;
        font: 12px/1 ui-sans-serif, system-ui;
        color: #cdd6f4;
      }
      .val {
        color: #e6eefc;
        font-weight: 700;
        margin-left: 8px;
        min-width: 84px;
        text-align: right;
      }
      input[type="range"] {
        width: 100%;
      }
      .btn {
        cursor: pointer;
        border: 1px solid #2a3340;
        background: #101825;
        color: #e6eefc;
        padding: 8px 12px;
        border-radius: 10px;
        font: 600 12px/1 ui-sans-serif, system-ui;
        margin-bottom: 6px;
      }
      .btn[aria-pressed="true"] {
        background: #1b2a40;
        border-color: #314257;
      }
    </style>
  </head>
  <body>
    <canvas id="glcanvas"></canvas>

    <div class="ui" id="controls">
      <button id="pulse" class="btn" aria-pressed="false">脉动：关 (P)</button>
      <button id="pluck" class="btn" aria-pressed="true">拨动：开 (O)</button>

      <div class="row">
        <h3 class="h">方块</h3>
        <div class="label">尺寸 <span id="vSize" class="val"></span></div>
        <input id="sizeRange" type="range" min="0" max="200" step="0.5" />
        <div class="label">圆角(px) <span id="vRadius" class="val"></span></div>
        <input id="radiusRange" type="range" min="0" max="100" step="0.5" />
        <div class="label">圆角AA(px) <span id="vAA" class="val"></span></div>
        <input id="aaRange" type="range" min="0" max="4" step="0.05" />
      </div>

      <div class="row">
        <h3 class="h">间距（边到边，可为负）</h3>
        <div class="label">
          水平间距 ΔX <span id="vGapX" class="val"></span>
        </div>
        <input id="gapXRange" type="range" min="-200" max="200" step="0.5" />
        <div class="label">
          垂直间距 ΔY <span id="vGapY" class="val"></span>
        </div>
        <input id="gapYRange" type="range" min="-200" max="200" step="0.5" />
        <div class="label">
          当前实际：X/Y <span id="vGapReal" class="val"></span>
        </div>
      </div>

      <div class="row">
        <h3 class="h">粘连/阈值</h3>
        <div class="label">连接范围 <span id="vCR" class="val"></span></div>
        <input id="crRange" type="range" min="0" max="12" step="0.1" />
        <div class="label">阈值 <span id="vTh" class="val"></span></div>
        <input id="thRange" type="range" min="0.1" max="4" step="0.01" />
        <div class="label">
          连接柔边(φ-AA) <span id="vPhiAA" class="val"></span>
        </div>
        <input id="phiAARange" type="range" min="0.0" max="1.5" step="0.01" />
        <div class="label">
          角偏置 Corner Bias <span id="vCBias" class="val"></span>
        </div>
        <input id="cbiasRange" type="range" min="0.2" max="2.5" step="0.01" />
      </div>

      <div class="row">
        <h3 class="h">脉动（默认关）</h3>
        <div class="label">速度 <span id="vSpeed" class="val"></span></div>
        <input id="speedRange" type="range" min="0" max="3" step="0.01" />
      </div>

      <div class="row">
        <h3 class="h">拨动波</h3>
        <div class="label">
          速度→强度比例 <span id="vRatio" class="val"></span>
        </div>
        <input id="ratioRange" type="range" min="0" max="0.1" step="0.001" />
        <div class="label">σ <span id="vSig" class="val"></span></div>
        <input id="sigRange" type="range" min="10" max="400" step="1" />
        <div class="label">f(Hz) <span id="vFq" class="val"></span></div>
        <input id="fqRange" type="range" min="0" max="5" step="0.01" />
        <div class="label">γ <span id="vGam" class="val"></span></div>
        <input id="gamRange" type="range" min="0" max="4" step="0.01" />
      </div>

      <div class="row">
        <h3 class="h">速度绑定（点按钮：正比 → 关 → 反比）</h3>
        <div style="display: flex; gap: 6px; flex-wrap: wrap">
          <button id="bindAmp" class="btn" aria-pressed="true">
            amp↔速：正比
          </button>
          <button id="bindSig" class="btn" aria-pressed="true">
            σ↔速：正比
          </button>
          <button id="bindFq" class="btn" aria-pressed="false">
            f↔速：关闭
          </button>
          <button id="bindGam" class="btn" aria-pressed="false">
            γ↔速：关闭
          </button>
        </div>
        <div class="label">
          速度上限(px/s) <span id="vSCap" class="val"></span>
        </div>
        <input id="speedCapRange" type="range" min="200" max="4000" step="10" />
        <div class="label">映射强度 <span id="vSEff" class="val"></span></div>
        <input id="speedEffRange" type="range" min="0" max="2" step="0.01" />
        <div class="label">当前速度 <span id="vMS" class="val"></span></div>
      </div>

      <div class="row">
        <h3 class="h">路径撒点</h3>
        <div class="label">
          投放间距 Δs(px) <span id="vDrop" class="val"></span>
        </div>
        <input id="dropDistRange" type="range" min="2" max="80" step="1" />
      </div>

      <div class="row">
        <h3 class="h">叠加保护 + 回弹</h3>
        <div class="label">
          位移上限(px) <span id="vCap" class="val"></span>
        </div>
        <input id="capRange" type="range" min="5" max="200" step="1" />
        <div class="label">
          复原时长 τ(s) <span id="vLife" class="val"></span>
        </div>
        <input id="lifeRange" type="range" min="0.3" max="8" step="0.1" />
      </div>
    </div>

    <script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script>
      (() => {
        // ====== 参数 & 存储 ======
        const STORE = "stickySquares.xyGap.aa.v7";
        const saved = (() => {
          try {
            return JSON.parse(localStorage.getItem(STORE) || "null");
          } catch {
            return null;
          }
        })();

        const snap05 = (v) => Math.round(v * 2) / 2;
        const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

        // DPR 冻结（形状/AA/步长用 DPR0；渲染与指针用 DPR_CUR）
        const DPR0 = Math.min(2, window.devicePixelRatio || 1);
        let DPR_CUR = DPR0;

        const CFG = {
          size: snap05(saved?.size ?? 24),
          corner: snap05(saved?.corner ?? 8),
          aa: saved?.aa ?? 1.0,
          pulseSpeedHz: 0.3,
          pulseMin: 0.0,
          connectRange: saved?.connectRange ?? 2.0,
          threshold: saved?.threshold ?? 1.0,
          phiAA: saved?.phiAA ?? 0.2,
          cornerBias: saved?.cornerBias ?? 1.0,
        };
        const GAP = {
          x: snap05(saved?.gapX ?? 8),
          y: snap05(saved?.gapY ?? 8),
        };
        const CELL = {
          stepX: snap05(saved?.stepX ?? 2 * CFG.size + GAP.x),
          stepY: snap05(saved?.stepY ?? 1 * CFG.size + GAP.y),
        };

        // 波形（路径撒点 & 立即回弹）
        const WAVE = {
          amp: saved?.amp ?? 20,
          sigma: saved?.sigma ?? 30,
          freq: saved?.freq ?? 3.0,
          gamma: saved?.gamma ?? 1.2,
        };
        const PLUCK = { ratio: saved?.ratio ?? 0.001, speedThreshold: 60 };
        const AMP_CAP = 20;

        // 速度绑定三态（默认关闭 f/γ 绑定，避免“停下时晚半拍”）
        const SPEEDBIND = {
          capPx: saved?.capPx ?? 1600,
          effect: saved?.effect ?? 1.0,
          ampMode: saved?.ampMode ?? 1,
          sigMode: saved?.sigMode ?? 1,
          fqMode: saved?.fqMode ?? 0,
          gamMode: saved?.gamMode ?? 0,
        };

        // 路径撒点
        const DROP = { dist: saved?.dropDist ?? 24 };
        const MAX_SUB_PER_MOVE = 24;

        // 叠加保护 + 回弹时长
        const LIMIT = {
          dispCap: saved?.dispCap ?? 120,
          lifeSec: saved?.lifeSec ?? 2.0,
        };
        const SINE_MIX = 1.2; // 初速度更大，生成即回弹

        function persist() {
          localStorage.setItem(
            STORE,
            JSON.stringify({
              size: CFG.size,
              corner: CFG.corner,
              aa: CFG.aa,
              gapX: GAP.x,
              gapY: GAP.y,
              stepX: CELL.stepX,
              stepY: CELL.stepY,
              connectRange: CFG.connectRange,
              threshold: CFG.threshold,
              phiAA: CFG.phiAA,
              cornerBias: CFG.cornerBias,
              amp: WAVE.amp,
              sigma: WAVE.sigma,
              freq: WAVE.freq,
              gamma: WAVE.gamma,
              ratio: PLUCK.ratio,
              capPx: SPEEDBIND.capPx,
              effect: SPEEDBIND.effect,
              ampMode: SPEEDBIND.ampMode,
              sigMode: SPEEDBIND.sigMode,
              fqMode: SPEEDBIND.fqMode,
              gamMode: SPEEDBIND.gamMode,
              dropDist: DROP.dist,
              dispCap: LIMIT.dispCap,
              lifeSec: LIMIT.lifeSec,
            })
          );
        }

        // ====== three.js 场景 ======
        const canvas = document.getElementById("glcanvas");
        const renderer = new THREE.WebGLRenderer({
          canvas,
          antialias: false,
          alpha: false,
          premultipliedAlpha: false,
        });
        renderer.setPixelRatio(1); // 我们自己管 DPR
        const scene = new THREE.Scene();
        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

        // 全屏大三角
        const geo = new THREE.BufferGeometry();
        geo.setAttribute(
          "position",
          new THREE.BufferAttribute(
            new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]),
            3
          )
        );

        // ====== Shader ======
        const MAX_PULSES = 128;
        const frag = `precision highp float;
uniform vec2  u_res; uniform float u_time;
uniform vec2  u_half0; uniform vec4  u_radius4; uniform vec2  u_step;
uniform float u_pulseMin, u_pulseHz; uniform float u_thresh, u_falloff, u_aa;
uniform float u_amp, u_sigma, u_freq, u_gamma;
uniform float u_phiAA; uniform float u_cornerBias;
uniform float u_pCount; uniform vec4 u_pulses[${MAX_PULSES}]; uniform float u_pGain[${MAX_PULSES}];
uniform float u_sineMix; uniform float u_dispCap; uniform float u_dispSoft;

float sdRoundBoxCorners(vec2 p, vec2 b, vec4 r4){
  vec2 s = sign(p);
  float r = (s.x>0.0) ? ((s.y>0.0)? r4.x : r4.w) : ((s.y>0.0)? r4.y : r4.z);
  r = clamp(r, 0.0, min(b.x,b.y)-1.0);
  vec2 q = abs(p) - (b - vec2(r));
  return length(max(q, vec2(0.0))) - r;
}
float cornerMask(vec2 p, vec2 b, vec4 r4){
  float rr = min(min(r4.x,r4.y), min(r4.z,r4.w));
  vec2 q = abs(p) - (b - vec2(rr));
  float cx = step(0.0, q.x), cy = step(0.0, q.y);
  return cx * cy;
}
vec2 displacementFromPulse(vec2 p, vec2 c, float ang, float t0, float gain){
  float age = max(0.0, u_time - t0);
  float r   = length(p - c) + 1e-3;
  float env = exp(-u_gamma * age) * exp(-r / max(1.0, u_sigma));
  float phase = 6.2831853 * u_freq * age;
  float osc = cos(phase) - u_sineMix * sin(phase);
  float a = (u_amp * gain) * env * osc;
  vec2 dir = vec2(cos(ang), sin(ang));
  return dir * a;
}
vec2 waveDisplacement(vec2 p){
  vec2 disp = vec2(0.0);
  for(int i=0;i<${MAX_PULSES};i++){
    float m = step(float(i), u_pCount);
    vec4 tp = u_pulses[i];
    disp += displacementFromPulse(p, tp.xy, tp.w, tp.z, u_pGain[i]) * m;
  }
  return disp;
}
void main(){
  vec2 uv = gl_FragCoord.xy;
  vec2 disp = waveDisplacement(uv);

  float cap = max(u_dispCap, 1.0);
  float soft = max(u_dispSoft, 1.0);
  float L = length(disp);
  if(L > 1e-3){
    float over = max(0.0, L - cap);
    float w = smoothstep(0.0, soft, over);
    float L_soft = cap + soft * (1.0 - exp(-over / soft));
    float L_new = mix(L, L_soft, w);
    disp *= (L_new / L);
  }
  vec2 uv2 = uv - disp;

  float phase = 0.5 + 0.5 * sin(6.2831853 * u_pulseHz * u_time);
  float pulse = u_pulseMin + (1.0 - u_pulseMin) * phase;

  vec2 C  = u_res * 0.5;
  float dmin = 1e6; float insideF = 0.0; float phi = 0.0;

  float jBase = floor((uv2.y - C.y) / u_step.y + 0.5);
  for(int jy=-1;jy<=1;jy++){
    float j = jBase + float(jy);
    float rowOff = mod(abs(j), 2.0) * 0.5;
    float iBase = floor((uv2.x - C.x - rowOff*u_step.x) / u_step.x + 0.5);
    for(int ix=-1; ix<=1; ix++){
      float i = iBase + float(ix);
      vec2 center = vec2(C.x + (i + rowOff) * u_step.x, C.y + j * u_step.y);
      vec2 hSize  = u_half0 * pulse;
      vec4 r4     = u_radius4 * pulse;
      vec2 lp = uv2 - center;
      float d = sdRoundBoxCorners(lp, hSize, r4);
      dmin = min(dmin, d);
      if(d <= 0.0) insideF = 1.0;
      float w = mix(1.0, u_cornerBias, cornerMask(lp, hSize, r4));
      phi += w * exp(-u_falloff * max(d, 0.0));
    }
  }
  float wAA = max(u_phiAA, 0.0001);
  float connected = smoothstep(u_thresh - wAA, u_thresh + wAA, phi);
  float edge = clamp(1.0 - smoothstep(0.0, u_aa, dmin), 0.0, 1.0);
  float mask = (insideF > 0.5) ? 1.0 : connected;
  mask = max(mask, edge * 0.95);
  gl_FragColor = vec4(vec3(mask), 1.0);
}`;
        const vert = `precision highp float; attribute vec3 position; void main(){ gl_Position = vec4(position, 1.0); }`;

        const uniforms = {
          u_res: { value: new THREE.Vector2(1, 1) },
          u_time: { value: 0 },
          u_half0: { value: new THREE.Vector2(12, 12) },
          u_radius4: { value: new THREE.Vector4(8, 8, 8, 8) },
          u_step: { value: new THREE.Vector2(64, 32) },
          u_pulseMin: { value: 1.0 },
          u_pulseHz: { value: 0.0 },
          u_thresh: { value: 1.0 },
          u_falloff: { value: 0.5 },
          u_aa: { value: 1.0 },
          u_amp: { value: WAVE.amp },
          u_sigma: { value: WAVE.sigma * DPR0 },
          u_freq: { value: WAVE.freq },
          u_gamma: { value: WAVE.gamma },
          u_phiAA: { value: CFG.phiAA },
          u_cornerBias: { value: CFG.cornerBias },
          u_pCount: { value: 0 },
          u_pulses: {
            value: Array.from(
              { length: MAX_PULSES },
              () => new THREE.Vector4(0, 0, 0, 0)
            ),
          },
          u_pGain: { value: Array.from({ length: MAX_PULSES }, () => 0) },
          u_sineMix: { value: SINE_MIX },
          u_dispCap: { value: LIMIT.dispCap * DPR0 },
          u_dispSoft: { value: LIMIT.dispCap * 2.0 * DPR0 }, // 放宽软饱和
          u_phiAA: { value: CFG.phiAA },
        };

        const material = new THREE.RawShaderMaterial({
          vertexShader: vert,
          fragmentShader: frag,
          uniforms,
          glslVersion: THREE.GLSL1,
        });
        const mesh = new THREE.Mesh(geo, material);
        scene.add(mesh);

        // ====== 尺寸与静态同步 ======
        function syncStatics() {
          const side = snap05(CFG.size);
          const halfPx = Math.round((side * DPR0) / 2);
          uniforms.u_half0.value.set(halfPx, halfPx);
          const r = snap05(CFG.corner);
          uniforms.u_radius4.value.set(r * DPR0, r * DPR0, r * DPR0, r * DPR0);
          uniforms.u_aa.value = Math.max(0.0, CFG.aa * DPR0);
          uniforms.u_thresh.value = CFG.threshold;
          uniforms.u_falloff.value =
            Math.log(2.0) / (Math.max(1e-3, CFG.connectRange) * DPR0);
          uniforms.u_phiAA.value = CFG.phiAA;
          uniforms.u_cornerBias.value = CFG.cornerBias;
          const sx = Math.round(Math.max(2, CELL.stepX * DPR0));
          const sy = Math.round(Math.max(2, CELL.stepY * DPR0));
          uniforms.u_step.value.set(sx, sy);
          uniforms.u_dispCap.value = LIMIT.dispCap * DPR0;
          uniforms.u_dispSoft.value = LIMIT.dispCap * 2.0 * DPR0; // 放宽
        }
        function applyPulseUniforms() {
          uniforms.u_pulseMin.value = pulseOn ? CFG.pulseMin : 1.0;
          uniforms.u_pulseHz.value = pulseOn ? CFG.pulseSpeedHz : 0.0;
        }
        function resize() {
          DPR_CUR = Math.min(2, window.devicePixelRatio || 1);
          const w = Math.floor(innerWidth * DPR_CUR),
            h = Math.floor(innerHeight * DPR_CUR);
          renderer.setSize(w, h, false);
          canvas.style.width = innerWidth + "px";
          canvas.style.height = innerHeight + "px";
          uniforms.u_res.value.set(w, h);
        }
        window.addEventListener("resize", resize);

        // ====== UI 句柄 ======
        const id = (x) => document.getElementById(x);
        const sizeR = id("sizeRange"),
          radR = id("radiusRange"),
          aaR = id("aaRange");
        const gapXR = id("gapXRange"),
          gapYR = id("gapYRange");
        const vSize = id("vSize"),
          vRad = id("vRadius"),
          vAA = id("vAA");
        const vGapX = id("vGapX"),
          vGapY = id("vGapY"),
          vGapReal = id("vGapReal");
        const spdR = id("speedRange"),
          vSpd = id("vSpeed");
        const crR = id("crRange"),
          vCR = id("vCR");
        const thR = id("thRange"),
          vTh = id("vTh");
        const phiAAR = id("phiAARange"),
          vPhiAA = id("vPhiAA");
        const cbiasR = id("cbiasRange"),
          vCBias = id("vCBias");
        const sigR = id("sigRange"),
          fqR = id("fqRange"),
          gamR = id("gamRange");
        const vSig = id("vSig"),
          vFq = id("vFq"),
          vGam = id("vGam");
        const ratioR = id("ratioRange"),
          vRatio = id("vRatio");
        const speedCapR = id("speedCapRange"),
          speedEffR = id("speedEffRange");
        const vSCap = id("vSCap"),
          vSEff = id("vSEff"),
          vMS = id("vMS");
        const bAmp = id("bindAmp"),
          bSig = id("bindSig"),
          bFq = id("bindFq"),
          bGam = id("bindGam");
        const dropR = id("dropDistRange"),
          vDrop = id("vDrop");
        const capR = id("capRange"),
          vCap = id("vCap");
        const lifeR = id("lifeRange"),
          vLife = id("vLife");

        function setBindLabel(btn, sym, mode) {
          btn.setAttribute("aria-pressed", mode !== 0);
          btn.textContent = `${sym}↔速：${
            mode === 1 ? "正比" : mode === 0 ? "关闭" : "反比"
          }`;
        }
        function cycleMode(m) {
          return m === 1 ? 0 : m === 0 ? -1 : 1;
        }
        function updateGapReadout() {
          const gx = snap05(CELL.stepX - 2 * CFG.size),
            gy = snap05(CELL.stepY - 1 * CFG.size);
          vGapReal.textContent = `${gx.toFixed(1)} / ${gy.toFixed(1)} px`;
        }

        function initSliders() {
          sizeR.value = CFG.size;
          vSize.textContent = CFG.size.toFixed(1) + " px";
          radR.value = CFG.corner;
          vRad.textContent = CFG.corner.toFixed(1) + " px";
          aaR.value = CFG.aa;
          vAA.textContent = CFG.aa.toFixed(2) + " px";
          gapXR.value = GAP.x;
          vGapX.textContent = GAP.x.toFixed(1) + " px";
          gapYR.value = GAP.y;
          vGapY.textContent = GAP.y.toFixed(1) + " px";
          spdR.value = CFG.pulseSpeedHz;
          vSpd.textContent = CFG.pulseSpeedHz.toFixed(2) + " Hz";
          crR.value = CFG.connectRange;
          vCR.textContent = CFG.connectRange.toFixed(1) + " px";
          thR.value = CFG.threshold;
          vTh.textContent = CFG.threshold.toFixed(2);
          phiAAR.value = CFG.phiAA;
          vPhiAA.textContent = CFG.phiAA.toFixed(2);
          cbiasR.value = CFG.cornerBias;
          vCBias.textContent = CFG.cornerBias.toFixed(2);
          sigR.value = WAVE.sigma;
          vSig.textContent = WAVE.sigma.toFixed(0) + " px";
          fqR.value = WAVE.freq;
          vFq.textContent = WAVE.freq.toFixed(2) + " Hz";
          gamR.value = WAVE.gamma;
          vGam.textContent = WAVE.gamma.toFixed(2);
          ratioR.value = PLUCK.ratio;
          vRatio.textContent = PLUCK.ratio.toFixed(3);
          speedCapR.value = SPEEDBIND.capPx;
          vSCap.textContent = SPEEDBIND.capPx + " px/s";
          speedEffR.value = SPEEDBIND.effect;
          vSEff.textContent = SPEEDBIND.effect.toFixed(2);
          vMS.textContent = "0 px/s";
          setBindLabel(bAmp, "amp", SPEEDBIND.ampMode);
          setBindLabel(bSig, "σ", SPEEDBIND.sigMode);
          setBindLabel(bFq, "f", SPEEDBIND.fqMode);
          setBindLabel(bGam, "γ", SPEEDBIND.gamMode);
          dropR.value = DROP.dist;
          vDrop.textContent = DROP.dist + " px";
          capR.value = LIMIT.dispCap;
          vCap.textContent = LIMIT.dispCap + " px";
          lifeR.value = LIMIT.lifeSec;
          vLife.textContent = LIMIT.lifeSec.toFixed(1) + " s";
          updateGapReadout();
        }

        // UI事件
        sizeR.oninput = () => {
          CFG.size = snap05(+sizeR.value);
          vSize.textContent = CFG.size.toFixed(1) + " px";
          syncStatics();
          updateGapReadout();
          persist();
        };
        radR.oninput = () => {
          CFG.corner = snap05(+radR.value);
          vRad.textContent = CFG.corner.toFixed(1) + " px";
          syncStatics();
          persist();
        };
        aaR.oninput = () => {
          CFG.aa = +aaR.value;
          vAA.textContent = CFG.aa.toFixed(2) + " px";
          syncStatics();
          persist();
        };
        gapXR.oninput = () => {
          GAP.x = snap05(+gapXR.value);
          vGapX.textContent = GAP.x.toFixed(1) + " px";
          CELL.stepX = snap05(Math.max(2, 2 * CFG.size + GAP.x));
          syncStatics();
          updateGapReadout();
          persist();
        };
        gapYR.oninput = () => {
          GAP.y = snap05(+gapYR.value);
          vGapY.textContent = GAP.y.toFixed(1) + " px";
          CELL.stepY = snap05(Math.max(2, 1 * CFG.size + GAP.y));
          syncStatics();
          updateGapReadout();
          persist();
        };
        spdR.oninput = () => {
          CFG.pulseSpeedHz = +spdR.value;
          vSpd.textContent = CFG.pulseSpeedHz.toFixed(2) + " Hz";
          applyPulseUniforms();
          persist();
        };
        crR.oninput = () => {
          CFG.connectRange = +crR.value;
          vCR.textContent = CFG.connectRange.toFixed(1) + " px";
          uniforms.u_falloff.value =
            Math.log(2.0) / (Math.max(1e-3, CFG.connectRange) * DPR0);
          persist();
        };
        thR.oninput = () => {
          CFG.threshold = +thR.value;
          vTh.textContent = CFG.threshold.toFixed(2);
          uniforms.u_thresh.value = CFG.threshold;
          persist();
        };
        phiAAR.oninput = () => {
          CFG.phiAA = +phiAAR.value;
          vPhiAA.textContent = CFG.phiAA.toFixed(2);
          uniforms.u_phiAA.value = CFG.phiAA;
          persist();
        };
        cbiasR.oninput = () => {
          CFG.cornerBias = +cbiasR.value;
          vCBias.textContent = CFG.cornerBias.toFixed(2);
          uniforms.u_cornerBias.value = CFG.cornerBias;
          persist();
        };
        sigR.oninput = () => {
          WAVE.sigma = +sigR.value;
          vSig.textContent = WAVE.sigma.toFixed(0) + " px";
          uniforms.u_sigma.value = WAVE.sigma * DPR0;
          persist();
        };
        fqR.oninput = () => {
          WAVE.freq = +fqR.value;
          vFq.textContent = WAVE.freq.toFixed(2) + " Hz";
          uniforms.u_freq.value = WAVE.freq;
          persist();
        };
        gamR.oninput = () => {
          WAVE.gamma = +gamR.value;
          vGam.textContent = WAVE.gamma.toFixed(2);
          const tau = Math.log(100.0) / Math.max(1e-4, WAVE.gamma);
          LIMIT.lifeSec = clamp(tau, 0.3, 8.0);
          lifeR.value = LIMIT.lifeSec;
          vLife.textContent = LIMIT.lifeSec.toFixed(1) + " s";
          uniforms.u_gamma.value = WAVE.gamma;
          persist();
        };
        ratioR.oninput = () => {
          PLUCK.ratio = +ratioR.value;
          vRatio.textContent = PLUCK.ratio.toFixed(3);
          persist();
        };
        speedCapR.oninput = () => {
          SPEEDBIND.capPx = +speedCapR.value;
          vSCap.textContent = SPEEDBIND.capPx + " px/s";
          persist();
        };
        speedEffR.oninput = () => {
          SPEEDBIND.effect = +speedEffR.value;
          vSEff.textContent = SPEEDBIND.effect.toFixed(2);
          persist();
        };
        dropR.oninput = () => {
          DROP.dist = +dropR.value;
          vDrop.textContent = DROP.dist + " px";
          persist();
        };
        capR.oninput = () => {
          LIMIT.dispCap = +capR.value;
          vCap.textContent = LIMIT.dispCap + " px";
          uniforms.u_dispCap.value = LIMIT.dispCap * DPR0;
          uniforms.u_dispSoft.value = LIMIT.dispCap * 2.0 * DPR0;
          persist();
        };
        lifeR.oninput = () => {
          LIMIT.lifeSec = +lifeR.value;
          vLife.textContent = LIMIT.lifeSec.toFixed(1) + " s";
          const gammaFromTau = Math.log(100.0) / Math.max(0.1, LIMIT.lifeSec);
          WAVE.gamma = gammaFromTau;
          vGam.textContent = WAVE.gamma.toFixed(2);
          uniforms.u_gamma.value = WAVE.gamma;
          persist();
        };

        bAmp.onclick = () => {
          SPEEDBIND.ampMode = cycleMode(SPEEDBIND.ampMode);
          setBindLabel(bAmp, "amp", SPEEDBIND.ampMode);
          persist();
        };
        bSig.onclick = () => {
          SPEEDBIND.sigMode = cycleMode(SPEEDBIND.sigMode);
          setBindLabel(bSig, "σ", SPEEDBIND.sigMode);
          persist();
        };
        bFq.onclick = () => {
          SPEEDBIND.fqMode = cycleMode(SPEEDBIND.fqMode);
          setBindLabel(bFq, "f", SPEEDBIND.fqMode);
          persist();
        };
        bGam.onclick = () => {
          SPEEDBIND.gamMode = cycleMode(SPEEDBIND.gamMode);
          setBindLabel(bGam, "γ", SPEEDBIND.gamMode);
          persist();
        };

        // 开关
        let pluckOn = true,
          pulseOn = false;
        const btnPulse = document.getElementById("pulse"),
          btnPluck = document.getElementById("pluck");
        function refreshButtons() {
          btnPulse.setAttribute("aria-pressed", pulseOn);
          btnPulse.textContent = `脉动：${pulseOn ? "开" : "关"} (P)`;
          btnPluck.setAttribute("aria-pressed", pluckOn);
          btnPluck.textContent = `拨动：${pluckOn ? "开" : "关"} (O)`;
        }
        btnPulse.onclick = () => {
          pulseOn = !pulseOn;
          refreshButtons();
          applyPulseUniforms();
          persist();
        };
        btnPluck.onclick = () => {
          pluckOn = !pluckOn;
          refreshButtons();
          persist();
        };
        window.addEventListener("keydown", (e) => {
          if (e.key === "p" || e.key === "P") btnPulse.click();
          if (e.key === "o" || e.key === "O") btnPluck.click();
        });
        refreshButtons();

        // ====== 速度映射（amp/sigma 仍可绑定；freq/gamma 默认关闭） ======
        let instSpeed = 0,
          smoothSpeed = 0;
        function mapBySpeed(base, mode) {
          if (mode === 0) return base;
          const s = Math.max(
            0,
            Math.min(1, smoothSpeed / Math.max(1, SPEEDBIND.capPx))
          );
          const g = 1 + s * SPEEDBIND.effect;
          return mode === 1 ? base * g : base / g;
        }

        // ====== 路径脉冲（CPU） ======
        const pulses = []; // {x,y,angle,t0,gain}
        function pushPulse(x, y, angle, t0, gain) {
          pulses.push({ x, y, angle, t0, gain });
        }
        function pruneAndUpload(now) {
          // 使用固定 γ 计算寿命，避免“刚停下还在变”的延迟感
          const g = Math.max(1e-4, WAVE.gamma);
          const life = clamp(Math.log(100.0) / g, 0.3, 8.0);
          let w = 0;
          for (let i = 0; i < pulses.length; i++) {
            if (now - pulses[i].t0 <= life) pulses[w++] = pulses[i];
          }
          pulses.length = w;

          const count = Math.min(pulses.length, MAX_PULSES);
          uniforms.u_pCount.value = count;
          const arrV = uniforms.u_pulses.value;
          const arrG = uniforms.u_pGain.value;
          for (let i = 0; i < MAX_PULSES; i++) {
            if (i < count) {
              const p = pulses[pulses.length - 1 - i]; // 近的放前面
              arrV[i].set(p.x, p.y, p.t0, p.angle);
              arrG[i] = p.gain;
            } else {
              arrV[i].set(0, 0, 0, 0);
              arrG[i] = 0;
            }
          }
        }

        // ====== 指针事件：按固定距离撒点（无“低速兜底脉冲”） ======
        const mouse = { prevX: 0, prevY: 0, tPrev: 0 };
        let emitResidue = 0;
        window.addEventListener(
          "pointermove",
          (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * DPR_CUR,
              y = (rect.bottom - e.clientY) * DPR_CUR;
            const now = performance.now() * 0.001,
              dt = Math.max(1e-3, now - mouse.tPrev);
            const vx = (x - mouse.prevX) / dt,
              vy = (y - mouse.prevY) / dt;

            instSpeed = Math.hypot(vx, vy);
            smoothSpeed = 0.25 * instSpeed + 0.75 * smoothSpeed;
            vMS.textContent = Math.round(smoothSpeed) + " px/s";

            if (pluckOn) {
              const ampPx = Math.min(AMP_CAP, instSpeed * PLUCK.ratio);
              const gain01 = ampPx / AMP_CAP;
              const angle = Math.atan2(vy, vx);

              const x0 = mouse.prevX,
                y0 = mouse.prevY;
              const segLen = Math.hypot(x - x0, y - y0);
              const sEmit = Math.max(2, DROP.dist * DPR_CUR);

              let need = Math.floor((emitResidue + segLen) / sEmit);
              if (need > MAX_SUB_PER_MOVE) need = MAX_SUB_PER_MOVE;

              if (segLen > 1e-4 && need > 0) {
                const dirx = (x - x0) / segLen,
                  diry = (y - y0) / segLen;
                const t0s = mouse.tPrev,
                  dtSeg = Math.max(1e-3, now - t0s);
                let dist = sEmit - emitResidue;
                for (let k = 0; k < need; k++) {
                  const u = dist / segLen;
                  const xi = x0 + dirx * dist;
                  const yi = y0 + diry * dist;
                  const ti = t0s + u * dtSeg;
                  pushPulse(xi, yi, angle || 0.0, ti, gain01);
                  dist += sEmit;
                }
                emitResidue = Math.max(0, emitResidue + segLen - need * sEmit);
              } else {
                // 不再兜底追加低速脉冲，避免“刚停下又被推了一把”的延迟感
                emitResidue = Math.min(emitResidue + segLen, sEmit);
              }
            }

            mouse.prevX = x;
            mouse.prevY = y;
            mouse.tPrev = now;
          },
          { passive: true }
        );

        window.addEventListener(
          "pointerdown",
          (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * DPR_CUR,
              y = (rect.bottom - e.clientY) * DPR_CUR;
            const now = performance.now() * 0.001;
            pushPulse(x, y, 0.0, now, 0.5);
            emitResidue = 0;
            mouse.prevX = x;
            mouse.prevY = y;
            mouse.tPrev = now;
          },
          { passive: true }
        );

        // ====== 渲染循环 ======
        let t0 = performance.now();
        function frame() {
          const t = (performance.now() - t0) * 0.001;
          uniforms.u_time.value = t;

          // amp/sigma 可选随速映射；freq/gamma 使用固定值，确保“生成即回弹”
          uniforms.u_amp.value = mapBySpeed(WAVE.amp, SPEEDBIND.ampMode);
          uniforms.u_sigma.value =
            mapBySpeed(WAVE.sigma, SPEEDBIND.sigMode) * DPR0;
          uniforms.u_freq.value = WAVE.freq;
          uniforms.u_gamma.value = WAVE.gamma;

          pruneAndUpload(t);
          renderer.render(scene, camera);
          requestAnimationFrame(frame);
        }

        // ====== 启动 ======
        resize();
        syncStatics();
        initSliders();
        applyPulseUniforms();
        frame();
      })();
    </script>
  </body>
</html>
