<!doctype html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>满屏粘连方块 · 脉动样式单选 + 行波/向心</title>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            background: #0b0f14
        }

        canvas {
            position: fixed;
            inset: 0;
            display: block;
            width: 100%;
            height: 100%
        }

        .ui {
            position: fixed;
            left: 16px;
            top: 16px;
            display: flex;
            gap: 8px;
            z-index: 10;
            flex-wrap: wrap;
            align-items: center;
            max-width: 96vw
        }

        .btn {
            cursor: pointer;
            border: 1px solid #2a3340;
            background: #101825;
            color: #e6eefc;
            padding: 8px 12px;
            border-radius: 10px;
            font: 600 12px/1 ui-sans-serif, system-ui
        }

        .btn[aria-pressed="true"] {
            background: #1b2a40;
            border-color: #314257
        }

        .panel {
            display: flex;
            gap: 12px;
            align-items: center;
            background: #0f141b;
            border: 1px solid #2a3340;
            padding: 8px 12px;
            border-radius: 12px
        }

        .panel label {
            font: 12px/1 ui-sans-serif, system-ui;
            color: #cdd6f4;
            opacity: .95
        }

        .panel input[type=range] {
            width: 160px
        }

        .val {
            min-width: 62px;
            display: inline-block;
            text-align: right;
            color: #e6eefc;
            font-weight: 600
        }

        .err {
            position: fixed;
            left: 16px;
            bottom: 16px;
            color: #ffebee;
            background: #3b1d22;
            border: 1px solid #6b2a36;
            border-radius: 8px;
            padding: 8px 10px;
            font: 12px/1.4 ui-sans-serif, system-ui;
            max-width: 70ch;
            white-space: pre-wrap;
            z-index: 10;
            display: none
        }
    </style>
</head>

<body>
    <canvas id="gl"></canvas>
    <canvas id="fallback" style="z-index:-1"></canvas>

    <div class="ui">
        <button id="pulse" class="btn" aria-pressed="true">脉动：开 (P)</button>
        <button id="pluck" class="btn" aria-pressed="true">拨动：开 (O)</button>

        <div class="panel">
            <label>尺寸 <span id="vSize" class="val"></span><input id="sizeRange" type="range" min="8" max="160"
                    step="1" /></label>
            <label>间隔 <span id="vGap" class="val"></span><input id="gapRange" type="range" min="0" max="120"
                    step="1" /></label>
            <label>圆角 <span id="vRadius" class="val"></span><input id="radiusRange" type="range" min="0" max="80"
                    step="1" /></label>
            <label>脉动速度 <span id="vSpeed" class="val"></span><input id="speedRange" type="range" min="0" max="3"
                    step="0.01" /></label>
            <label>连接范围 <span id="vCR" class="val"></span><input id="crRange" type="range" min="0" max="12"
                    step="0.1" /></label>
            <label>阈值 <span id="vTh" class="val"></span><input id="thRange" type="range" min="0.1" max="4"
                    step="0.01" /></label>
        </div>

        <div class="panel">
            <label>拨动强度上限 <span class="val">20</span></label>
            <label>速度→强度比例 <span id="vRatio" class="val"></span><input id="ratioRange" type="range" min="0" max="0.1"
                    step="0.001" /></label>
            <label>释放延时(ms) <span id="vDelay" class="val"></span><input id="delayRange" type="range" min="0" max="500"
                    step="10" /></label>
        </div>

        <div class="panel">
            <label>拨动强度基准(amp) <span class="val">20</span></label>
            <label>空间衰减σ <span id="vSig" class="val"></span><input id="sigRange" type="range" min="10" max="400"
                    step="1" /></label>
            <label>波长λ <span id="vLam" class="val"></span><input id="lamRange" type="range" min="20" max="800"
                    step="1" /></label>
            <label>频率Hz <span id="vFq" class="val"></span><input id="fqRange" type="range" min="0" max="5"
                    step="0.01" /></label>
            <label>时间阻尼γ <span id="vGam" class="val"></span><input id="gamRange" type="range" min="0" max="4"
                    step="0.01" /></label>
        </div>

        <div class="panel">
            <button id="bindAmp" class="btn" aria-pressed="true">amp↔速：正比</button>
            <button id="bindSig" class="btn" aria-pressed="true">σ↔速：正比</button>
            <button id="bindLam" class="btn" aria-pressed="true">λ↔速：正比</button>
            <button id="bindFq" class="btn" aria-pressed="true">f↔速：正比</button>
            <button id="bindGam" class="btn" aria-pressed="true">γ↔速：正比</button>
            <label>映射用速度上限(px/s) <span id="vSCap" class="val"></span><input id="speedCapRange" type="range" min="200"
                    max="4000" step="10" /></label>
            <label>映射强度 <span id="vSEff" class="val"></span><input id="speedEffRange" type="range" min="0" max="2"
                    step="0.01" /></label>
            <label>当前速度 <span id="vMS" class="val"></span></label>
        </div>

        <div class="panel">
            <label>影响范围最大格数 <span id="vMaxCells" class="val"></span><input id="maxCellsRange" type="range" min="80"
                    max="2000" step="1" /></label>
            <label>速度放大倍率上限 <span id="vMaxScale" class="val"></span><input id="maxScaleRange" type="range" min="1.0"
                    max="3.0" step="0.01" /></label>
        </div>

        <div class="panel">
            <button id="capToggle" class="btn" aria-pressed="true">拨动限速：开</button>
            <label>拨动速度硬上限(px/s) <span id="vPluckCap" class="val"></span><input id="pluckCapRange" type="range"
                    min="200" max="4000" step="10" /></label>
        </div>

        <!-- ★ 新增：脉动样式 + 脉动波长 -->
        <div class="panel">
            <fieldset style="display:flex;gap:12px;align-items:center;border:none;padding:0;margin:0">
                <legend style="color:#cdd6f4;font:600 12px/1 ui-sans-serif,system-ui;opacity:.95">脉动样式</legend>
                <label><input type="radio" name="pulseMode" value="1" checked> 左下→右上 行波</label>
                <label><input type="radio" name="pulseMode" value="2"> 对角向中心往复</label>
            </fieldset>
            <label>脉动波长λ(px) <span id="vPulseLam" class="val"></span>
                <input id="pulseLamRange" type="range" min="40" max="800" step="1" />
            </label>
        </div>

        <!-- 闲置速收尾 + 水滴 AOE（保留你的上一版面板） -->
        <div class="panel">
            <label>闲置收尾强度 <span id="vFadeRate" class="val"></span><input id="fadeRateRange" type="range" min="0"
                    max="100" step="0.1" /></label>
            <label>AOE速度下限 <span id="vSpeedMin" class="val"></span><input id="speedMinRange" type="range" min="10"
                    max="300" step="5" /></label>
            <label>水滴前伸 <span id="vDropFront" class="val"></span><input id="dropFrontRange" type="range" min="0" max="2"
                    step="0.05" /></label>
            <label>水滴横向挤压 <span id="vDropSqueeze" class="val"></span><input id="dropSqueezeRange" type="range" min="0"
                    max="0.8" step="0.02" /></label>
        </div>
    </div>

    <div id="err" class="err"></div>

    <script>
        (() => {

            // 你的现有参数（保持一致）
            const CFG = {
                size: 18,
                corner: 3,
                extraGap: 4,
                pulseSpeedHz: 0.3,
                pulseMin: 0.0,
                connectRange: 2.0,
                threshold: 1.0,
                aa: 1.0
            };
            const WAVE = {
                amp: 20,
                sigma: 30,
                lambda: 68,
                freq: 1.2,
                gamma: 1.0
            };
            const PLUCK = {
                ratio: 0.001,
                delayMs: 200,
                speedThreshold: 60,
                capEnable: true,
                capPx: 550
            };
            const SPEEDBIND = {
                capPx: 1600,
                effect: 1.0,
                ampDir: true,
                sigDir: true,
                lamDir: true,
                fqDir: true,
                gamDir: true
            };
            const SPRING = {
                k: 60.0,
                c: 8.0,
                mass: 1.0,
                gainRatio: 0.02,
                maxImpulse: 500.0,
                samplesPerStep: 3
            };
            const SCALE = {
                k: 50.0,
                c: 10.0,
                mass: 1.0,
                followGain: 6.0,
                maxScale: 1.25
            };
            const AOE = {
                maxCells: 200
            };

            const REBOUND = {
                enable: true,
                posKMin: 0.35,
                sizeKMin: 0.50,
                recoverRate: 1.5
            };
            const STOP = {
                high: 400,
                low: 80,
                radiusCells: 1.5,
                velCut: 0.35
            };
            const FADE = {
                idleMs: 200,
                forceRate: 8.0,
                restDisp: 0.6,
                restVel: 2.0,
                restScaleEps: 0.01
            };

            // ★ 新增：脉动样式配置
            const PULSEFX = {
                mode: 1, // 1=行波(左下→右上)，2=对角向中心往复
                lambdaPx: 240 // 脉动波长（像素）
            };

            // ★ 新增：水滴（保留）
            const DROP = {
                speedMin: 50,
                front: 1.30,
                squeeze: 0.35,
                singleTail: true, // 开关：用单尾水滴形状
                headRatio: 0.55, // 前端“圆头”的相对半径（占 rPx 的比例）
                tailTaper: 0.75 // 尾巴横向收缩强度（0~1，越大越尖）
            };

            // ——（后面全部是你上一版逻辑，略有增量） ——
            {
                const cCrit = 2 * Math.sqrt(SCALE.k * SCALE.mass);
                SCALE.c = Math.max(SCALE.c, cCrit * 1.05);
            }

            const DPR = Math.min(2, window.devicePixelRatio || 1);
            const glCanvas = document.getElementById('gl');
            const fbCanvas = document.getElementById('fallback');
            const errBox = document.getElementById('err');
            const showErr = (m) => {
                errBox.style.display = 'block';
                errBox.textContent = m;
                fbCanvas.style.zIndex = '1';
            };

            const gl = glCanvas.getContext('webgl', {
                antialias: false,
                alpha: false
            });
            if (!gl) {
                showErr('未启用 WebGL，已回退 Canvas2D。');
                startFallback();
                return;
            }
            if (!gl.getExtension('OES_texture_float')) {
                showErr('需要 WebGL 扩展：OES_texture_float');
                return;
            }

            gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
            gl.pixelStorei(gl.PACK_ALIGNMENT, 1);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);

            const VERT = `
    #ifdef GL_ES
    precision highp float;
    #endif
    attribute vec2 a_pos;
    void main(){ gl_Position = vec4(a_pos,0.0,1.0); }`;

            // ★ FRAG：加入 u_pulseMode / u_waveLambda，并根据模式生成 basePulse
            const FRAG = `
    #ifdef GL_ES
      #ifdef GL_FRAGMENT_PRECISION_HIGH
        precision highp float;
      #else
        precision mediump float;
      #endif
    #else
      precision highp float;
    #endif

    uniform vec2  u_res;
    uniform float u_time;

    uniform vec2  u_half0;
    uniform vec4  u_radius4;
    uniform vec2  u_step;
    uniform float u_pulseMin, u_pulseHz;
    uniform float u_thresh, u_falloff, u_aa;
    uniform float u_pulseOn;

    uniform int   u_pulseMode;   // ★ 1 or 2
    uniform float u_waveLambda;  // ★ 像素

    uniform vec2  u_texSize;
    uniform ivec2 u_gridMin;
    uniform sampler2D u_dispTex;
    uniform float u_scanR;

    float sdRoundBoxCorners(vec2 p, vec2 b, vec4 r4){
      vec2 s = sign(p);
      float r = (s.x>0.0) ? ((s.y>0.0)? r4.x : r4.w)
                          : ((s.y>0.0)? r4.y : r4.z);
      r = clamp(r, 0.0, min(b.x,b.y)-1.0);
      vec2 q = abs(p) - (b - vec2(r));
      return length(max(q, vec2(0.0))) - r;
    }

    vec3 fetchDispScale(ivec2 ij){
      ivec2 ij0 = ij - u_gridMin;
      vec2 uv   = (vec2(ij0) + 0.5) / u_texSize;
      return texture2D(u_dispTex, uv).rgb; // R=dx, G=dy, B=scaleAbs(>1)|0
    }

    float pulseBase(vec2 uv){
      // 默认：全局同相位（向后兼容）
      float phase0 = 0.5 + 0.5 * sin(6.2831853 * u_pulseHz * u_time);
      float baseDefault = u_pulseMin + (1.0 - u_pulseMin) * phase0;

      // 统一使用 NE 方向 (1,1) / sqrt(2)
      vec2 n = normalize(vec2(1.0, 1.0));
      float k = 6.2831853 / max(1.0, u_waveLambda);
      float w = 6.2831853 * u_pulseHz;

      if(u_pulseMode == 1){
        // 样式A：左下→右上 行波（沿 n 正向传播）
        float s = dot(uv, n);
        float ph = k*s - w*u_time;
        float run = u_pulseMin + (1.0 - u_pulseMin) * (0.5 + 0.5 * sin(ph));
        return run;
      }else if(u_pulseMode == 2){
        // 样式B：对角向中心往复（来自左上与右下的对向波叠加）
        float s1 = dot(uv, n);
        float s2 = dot(u_res - uv, n);
        float ph1 = k*s1 - w*u_time;
        float ph2 = k*s2 - w*u_time;
        // 归一到 [0,1]，中间加强
        float comb = 0.5 + 0.25*(sin(ph1) + sin(ph2));
        float run = u_pulseMin + (1.0 - u_pulseMin) * comb;
        return run;
      }else{
        return baseDefault;
      }
    }

    void main(){
      vec2 uv = gl_FragCoord.xy;
      vec2 C  = u_res * 0.5;

      // ★ 基于模式的脉动（pulseOn=0 → 退化为 1.0）
      float basePulse = pulseBase(uv);
      float pulse     = mix(1.0, basePulse, step(0.5, u_pulseOn));

      float dmin = 1e6;
      float insideF = 0.0;
      float phi = 0.0;

      const int MAX_SCAN = 20;
      float jBase = floor((uv.y - C.y) / u_step.y + 0.5);
      for(int jy=-MAX_SCAN; jy<=MAX_SCAN; jy++){
        if (abs(float(jy)) > u_scanR) continue;
        float j = jBase + float(jy);
        float rowOff = mod(abs(j), 2.0) * 0.5;
        float iBase = floor((uv.x - C.x - rowOff*u_step.x) / u_step.x + 0.5);
        for(int ix=-MAX_SCAN; ix<=MAX_SCAN; ix++){
          if (abs(float(ix)) > u_scanR) continue;

          float i = iBase + float(ix);
          vec2 center = vec2(C.x + (i + rowOff) * u_step.x,
                             C.y +  j            * u_step.y);

          vec3 ds = fetchDispScale(ivec2(int(i), int(j)));
          center += ds.rg;

          float sizeFactor = (ds.b > 0.0) ? max(pulse, ds.b) : pulse;

          vec2 hSize  = u_half0 * sizeFactor;
          vec4 r4     = u_radius4 * sizeFactor;
          float d     = sdRoundBoxCorners(uv - center, hSize, r4);

          dmin = min(dmin, d);
          if(d <= 0.0) insideF = 1.0;
          phi += exp(-u_falloff * max(d, 0.0));
        }
      }

      float mask = (insideF > 0.5) ? 1.0 : step(u_thresh, phi);
      float edge = clamp(1.0 - smoothstep(0.0, u_aa, dmin), 0.0, 1.0);
      mask = max(mask, edge * 0.95);
      gl_FragColor = vec4(vec3(mask), 1.0);
    }`;

            function compile(type, src) {
                const s = gl.createShader(type);
                gl.shaderSource(s, src);
                gl.compileShader(s);
                if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
                    const log = gl.getShaderInfoLog(s) || '(empty log)';
                    gl.deleteShader(s);
                    throw new Error(log);
                }
                return s;
            }
            let prog;
            try {
                prog = gl.createProgram();
                gl.attachShader(prog, compile(gl.VERTEX_SHADER, VERT));
                gl.attachShader(prog, compile(gl.FRAGMENT_SHADER, FRAG));
                gl.linkProgram(prog);
                if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(prog));
            } catch (e) {
                showErr('WebGL 着色器失败：' + e.message + '。已回退 Canvas2D。');
                startFallback();
                return;
            }
            gl.useProgram(prog);

            // 全屏三角
            const buf = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, buf);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 3, -1, -1, 3]), gl.STATIC_DRAW);
            const a_pos = gl.getAttribLocation(prog, 'a_pos');
            gl.enableVertexAttribArray(a_pos);
            gl.vertexAttribPointer(a_pos, 2, gl.FLOAT, false, 0, 0);

            // uniforms
            const U = n => gl.getUniformLocation(prog, n);
            const u_res = U('u_res'),
                u_time = U('u_time');
            const u_half0 = U('u_half0'),
                u_radius4 = U('u_radius4'),
                u_step = U('u_step');
            const u_pulseMin = U('u_pulseMin'),
                u_pulseHz = U('u_pulseHz'),
                u_pulseOn = U('u_pulseOn');
            const u_thresh = U('u_thresh'),
                u_falloff = U('u_falloff'),
                u_aa = U('u_aa');
            const u_dispTex = U('u_dispTex'),
                u_texSize = U('u_texSize'),
                u_gridMin = U('u_gridMin');
            const u_scanR = U('u_scanR');
            const u_pulseMode = U('u_pulseMode'); // ★
            const u_waveLambda = U('u_waveLambda'); // ★

            function syncStatics() {
                gl.uniform2f(u_half0, (CFG.size * DPR) / 2, (CFG.size * DPR) / 2);
                const r = CFG.corner * DPR;
                gl.uniform4f(u_radius4, r, 0.0, r, 0.0);
                gl.uniform1f(u_pulseMin, CFG.pulseMin);
                gl.uniform1f(u_pulseHz, CFG.pulseSpeedHz);
                gl.uniform1f(u_pulseOn, 1.0);
                gl.uniform1f(u_thresh, CFG.threshold);
                gl.uniform1f(u_aa, CFG.aa * DPR);
                gl.uniform1i(u_pulseMode, PULSEFX.mode); // ★
                gl.uniform1f(u_waveLambda, PULSEFX.lambdaPx * DPR); // ★（像素→设备像素）
                const k = Math.log(2.0) / (Math.max(1e-3, CFG.connectRange) * DPR);
                gl.uniform1f(u_falloff, k);
                syncStep();
            }

            function syncStep() {
                const s = CFG.size * DPR;
                const stepX = s * 2.0 + CFG.extraGap * 2 * DPR;
                const stepY = s + CFG.extraGap * DPR;
                gl.uniform2f(u_step, stepX, stepY);
                initSpringField();
                syncSpringUniforms();
            }

            function resize() {
                const w = Math.floor(innerWidth * DPR),
                    h = Math.floor(innerHeight * DPR);
                glCanvas.width = w;
                glCanvas.height = h;
                glCanvas.style.width = innerWidth + 'px';
                glCanvas.style.height = innerHeight + 'px';
                gl.viewport(0, 0, w, h);
                gl.uniform2f(u_res, w, h);
                initSpringField();
                syncSpringUniforms();
            }
            addEventListener('resize', resize);

            // —— 弹簧场（与上一版一致，省略注释） ——
            let cols = 0,
                rows = 0,
                iMin = 0,
                jMin = 0;
            let dispArray = null,
                velArray = null,
                scaleArray = null,
                scaleVelArray = null,
                scaleLock = null;
            let posKFactor = null,
                sizeKFactor = null,
                lastTouch = null;
            let dispTex = null;

            function gridMetrics() {
                const s = CFG.size * DPR;
                return {
                    stepX: s * 2.0 + CFG.extraGap * 2 * DPR,
                    stepY: s + CFG.extraGap * DPR
                };
            }

            function initSpringField() {
                const w = glCanvas.width,
                    h = glCanvas.height;
                const {
                    stepX,
                    stepY
                } = gridMetrics();
                const iSpan = Math.ceil((w / stepX) + 6),
                    jSpan = Math.ceil((h / stepY) + 6);
                iMin = -iSpan;
                jMin = -jSpan;
                const iMax = iSpan,
                    jMax = jSpan;
                cols = iMax - iMin + 1;
                rows = jMax - jMin + 1;

                dispArray = new Float32Array(cols * rows * 2);
                velArray = new Float32Array(cols * rows * 2);
                scaleArray = new Float32Array(cols * rows);
                scaleVelArray = new Float32Array(cols * rows);
                scaleLock = new Uint8Array(cols * rows);
                posKFactor = new Float32Array(cols * rows);
                sizeKFactor = new Float32Array(cols * rows);
                lastTouch = new Float64Array(cols * rows);
                for (let q = 0; q < cols * rows; q++) {
                    scaleArray[q] = 1.0;
                    posKFactor[q] = 1.0;
                    sizeKFactor[q] = 1.0;
                    lastTouch[q] = 0;
                }

                if (!dispTex) dispTex = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, dispTex);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, cols, rows, 0, gl.RGBA, gl.FLOAT, new Float32Array(cols *
                    rows * 4));
            }

            function syncSpringUniforms() {
                gl.uniform2f(u_texSize, cols, rows);
                gl.uniform2i(u_gridMin, iMin, jMin);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, dispTex);
                gl.uniform1i(u_dispTex, 0);
            }
            const idx2 = (i, j) => {
                const ii = i - iMin,
                    jj = j - jMin;
                if (ii < 0 || ii >= cols || jj < 0 || jj >= rows) return -1;
                return jj * cols + ii;
            };
            const idx = (i, j) => {
                const base = idx2(i, j);
                return base < 0 ? -1 : base * 2;
            };

            function nearestIndex(x, y) {
                const w = glCanvas.width,
                    h = glCanvas.height,
                    Cx = w * 0.5,
                    Cy = h * 0.5;
                const {
                    stepX,
                    stepY
                } = gridMetrics();
                const j = Math.floor((y - Cy) / stepY + 0.5);
                const ro = (Math.abs(j) % 2) * 0.5;
                const i = Math.floor((x - Cx - ro * stepX) / stepX + 0.5);
                return {
                    i,
                    j
                };
            }

            function centerOf(i, j) {
                const w = glCanvas.width,
                    h = glCanvas.height,
                    Cx = w * 0.5,
                    Cy = h * 0.5;
                const {
                    stepX,
                    stepY
                } = gridMetrics();
                const ro = (Math.abs(j) % 2) * 0.5;
                return {
                    cx: Cx + (i + ro) * stepX,
                    cy: Cy + j * stepY
                };
            }

            function stepSprings() {
                const now = performance.now() * 0.001;
                const dtRaw = now - (stepSprings._t || now);
                stepSprings._t = now;
                let dt = Math.min(Math.max(dtRaw, 1 / 120), 1 / 30);

                const invM = 1.0 / SPRING.mass;
                for (let j = 0; j < rows; j++) {
                    for (let i = 0; i < cols; i++) {
                        const p = (j * cols + i) * 2,
                            base = j * cols + i;
                        let x = dispArray[p],
                            y = dispArray[p + 1];
                        let vx = velArray[p],
                            vy = velArray[p + 1];
                        const fac = REBOUND.enable ? Math.max(0.05, Math.min(1.0, posKFactor[base])) : 1.0;
                        const kEff = SPRING.k * fac,
                            cEff = SPRING.c * Math.sqrt(fac);
                        const ax = (-kEff * x - cEff * vx) * invM;
                        const ay = (-kEff * y - cEff * vy) * invM;
                        vx += ax * dt;
                        x += vx * dt;
                        vy += ay * dt;
                        y += vy * dt;
                        dispArray[p] = x;
                        dispArray[p + 1] = y;
                        velArray[p] = vx;
                        velArray[p + 1] = vy;
                        if (REBOUND.enable) {
                            const r = Math.min(1.0, REBOUND.recoverRate * dt);
                            posKFactor[base] += (1.0 - posKFactor[base]) * r;
                        }
                    }
                }

                const invMs = 1.0 / SCALE.mass;
                for (let j = 0; j < rows; j++) {
                    for (let i = 0; i < cols; i++) {
                        const base = j * cols + i;
                        if (scaleLock[base]) {
                            scaleArray[base] = 1.0;
                            scaleVelArray[base] = 0.0;
                            if (REBOUND.enable) {
                                const r = Math.min(1.0, REBOUND.recoverRate * dt);
                                sizeKFactor[base] += (1.0 - sizeKFactor[base]) * r;
                            }
                            continue;
                        }
                        let s = scaleArray[base],
                            vs = scaleVelArray[base];
                        const fac = REBOUND.enable ? Math.max(0.05, Math.min(1.0, sizeKFactor[base])) : 1.0;
                        const kEff = SCALE.k * fac,
                            cEff = (2 * Math.sqrt(kEff * SCALE.mass)) * 1.05;
                        const ds = (1.0 - s);
                        const as = (kEff * ds - cEff * vs) * invMs;
                        vs += as * dt;
                        const sNext = s + vs * dt;
                        if (s > 1.0 && sNext <= 1.0 && vs < 0.0) {
                            s = 1.0;
                            vs = 0.0;
                            scaleLock[base] = 1;
                        } else {
                            s = sNext;
                        }
                        s = Math.max(0.2, Math.min(3.0, s));
                        vs = Math.max(-1000, Math.min(1000, vs));
                        scaleArray[base] = s;
                        scaleVelArray[base] = vs;
                        if (REBOUND.enable) {
                            const r = Math.min(1.0, REBOUND.recoverRate * dt);
                            sizeKFactor[base] += (1.0 - sizeKFactor[base]) * r;
                        }
                    }
                }

                // 闲置自动收尾
                {
                    const rForce = Math.min(1.0, FADE.forceRate * dt);
                    for (let j = 0; j < rows; j++) {
                        for (let i = 0; i < cols; i++) {
                            const base = j * cols + i;
                            const idleSec = now - (lastTouch[base] || 0);
                            if (idleSec < FADE.idleMs * 0.001) continue;
                            const p = base * 2;
                            dispArray[p] += (0 - dispArray[p]) * rForce;
                            dispArray[p + 1] += (0 - dispArray[p + 1]) * rForce;
                            velArray[p] *= (1 - rForce);
                            velArray[p + 1] *= (1 - rForce);
                            scaleArray[base] += (1.0 - scaleArray[base]) * rForce;
                            scaleVelArray[base] *= (1 - rForce);
                            posKFactor[base] += (1.0 - posKFactor[base]) * rForce;
                            sizeKFactor[base] += (1.0 - sizeKFactor[base]) * rForce;
                            const almostStill =
                                Math.abs(dispArray[p]) < FADE.restDisp && Math.abs(dispArray[p + 1]) < FADE
                                .restDisp &&
                                Math.abs(velArray[p]) < FADE.restVel && Math.abs(velArray[p + 1]) < FADE.restVel &&
                                Math.abs(scaleArray[base] - 1.0) < FADE.restScaleEps && Math.abs(scaleVelArray[
                                    base]) < 0.5;
                            if (almostStill) {
                                dispArray[p] = 0;
                                dispArray[p + 1] = 0;
                                velArray[p] = 0;
                                velArray[p + 1] = 0;
                                scaleArray[base] = 1.0;
                                scaleVelArray[base] = 0.0;
                                scaleLock[base] = 1;
                                posKFactor[base] = 1.0;
                                sizeKFactor[base] = 1.0;
                                lastTouch[base] = now;
                            }
                        }
                    }
                }

                // 写纹理
                const tex = new Float32Array(cols * rows * 4);
                for (let j = 0; j < rows; j++) {
                    for (let i = 0; i < cols; i++) {
                        const base = j * cols + i,
                            p2 = base * 2,
                            p4 = base * 4;
                        tex[p4] = dispArray[p2];
                        tex[p4 + 1] = dispArray[p2 + 1];
                        const sAbs = scaleArray[base];
                        tex[p4 + 2] = (!scaleLock[base] && sAbs > 1.01) ? sAbs : 0.0;
                        tex[p4 + 3] = 1.0;
                    }
                }
                gl.bindTexture(gl.TEXTURE_2D, dispTex);
                gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, cols, rows, gl.RGBA, gl.FLOAT, tex);

                // 扫描半径
                let maxD = 0;
                for (let j = 0; j < rows; j++) {
                    for (let i = 0; i < cols; i++) {
                        const p2 = (j * cols + i) * 2;
                        const d = Math.hypot(dispArray[p2], dispArray[p2 + 1]);
                        if (d > maxD) maxD = d;
                    }
                }
                const {
                    stepX,
                    stepY
                } = gridMetrics();
                const stepMin = Math.min(stepX, stepY);
                const rCellsNeeded = Math.ceil(maxD / stepMin) + 1;
                const MAX_SCAN_JS = 20;
                gl.uniform1f(u_scanR, Math.min(rCellsNeeded, MAX_SCAN_JS));
            }

            const cellsToRadiusCells = (n) => Math.max(0.5, Math.sqrt(Math.max(1, n) / Math.PI));

            let lastDirX = 1,
                lastDirY = 0;
            const DROPcfg = DROP;

            function injectAOE(x, y, speed, vx, vy) {
                const sp = Math.hypot(vx, vy);
                let dirx = lastDirX,
                    diry = lastDirY;
                if (sp > 1e-3) {
                    dirx = vx / sp;
                    diry = vy / sp;
                    lastDirX = dirx;
                    lastDirY = diry;
                }

                const sMin = Math.max(0, DROPcfg.speedMin),
                    sMax = PLUCK.capPx;
                const s01_raw = (speed - sMin) / Math.max(1, (sMax - sMin));
                const s01 = Math.max(0, Math.min(1, s01_raw));

                const speedForImpulse = PLUCK.capEnable ? Math.min(speed, PLUCK.capPx) : speed;
                const gainBase = Math.min(SPRING.maxImpulse, speedForImpulse * SPRING.gainRatio);
                const mulAbs = 1.0 + s01 * (SCALE.maxScale - 1.0);

                const targetCells = 1 + Math.floor(s01 * (AOE.maxCells - 1));
                const rCells = cellsToRadiusCells(targetCells);
                const {
                    stepX,
                    stepY
                } = gridMetrics();
                const unit = Math.min(stepX, stepY);
                const rPx = rCells * unit;

                const {
                    i: ic,
                    j: jc
                } = nearestIndex(x, y);
                const rI = Math.ceil(rPx / stepX) + 1,
                    rJ = Math.ceil(rPx / stepY) + 1;

                const rFront = rPx * (1 + DROPcfg.front * s01);
                const rBack = rPx * (1 - 0.20 * s01);
                const rSide = Math.max(0.4 * rPx, rPx * (1 - DROPcfg.squeeze * s01));
                const dirPerpX = -diry,
                    dirPerpY = dirx;

                const posFac = REBOUND.enable ? (1.0 - s01 * (1.0 - REBOUND.posKMin)) : 1.0;
                const sizeFac = REBOUND.enable ? (1.0 - s01 * (1.0 - REBOUND.sizeKMin)) : 1.0;

                for (let dj = -rJ; dj <= rJ; dj++) {
                    const j = jc + dj;
                    for (let di = -rI; di <= rI; di++) {
                        const i = ic + di;
                        const base = idx2(i, j);
                        if (base < 0) continue;
                        const p = base * 2;
                        const {
                            cx,
                            cy
                        } = centerOf(i, j);
                        const dx = cx - x,
                            dy = cy - y;
                        const par = dx * dirx + dy * diry;
                        const perpSigned = dx * dirPerpX + dy * dirPerpY; // 不取绝对值，先保留符号
                        const perp = Math.abs(perpSigned);

                        // 默认：沿用旧椭圆（以便随时切回）
                        let inside = false;
                        let w = 0.0;

                        if (!DROP.singleTail) {
                            const rLong = par >= 0 ? rFront : rBack;
                            const d = Math.sqrt((par * par) / (rLong * rLong) + (perp * perp) / (rSide * rSide));
                            if (d <= 1.0) {
                                const t = d;
                                w = 1.0 - (t * t * (3.0 - 2.0 * t));
                                inside = true;
                            }
                        } else {
                            // —— 单尾水滴：前圆头 + 后锥尾 ——
                            // 头：一个较小的“圆帽”/胶囊；尾：横向半径随 -par 渐缩
                            const headR = Math.max(0.1 * rPx, DROP.headRatio * rPx); // 圆头纵向半径
                            const tailL = rBack; // 尾巴长度 = 你原来的 rBack
                            // 前头（par>=0）：圆头 + 略宽横向（用 rSide）
                            if (par >= 0.0) {
                                const dHead = Math.sqrt((par * par) / (headR * headR) + (perp * perp) / (rSide *
                                    rSide));
                                if (dHead <= 1.0) {
                                    const t = dHead;
                                    w = 1.0 - (t * t * (3.0 - 2.0 * t));
                                    inside = true;
                                }
                            } else {
                                // 尾部（par<0）：横向半径从 rSide 逐渐收缩到很小，形成“单条尾巴”
                                const tau = Math.min(1.0, (-par) / Math.max(1e-6, tailL)); // 0 在脖颈，1 在尾端
                                // 横向半径随 tau 收缩：1 → (1 - tailTaper)
                                const side = Math.max(0.12 * rSide, rSide * (1.0 - DROP.tailTaper * tau));
                                // 纵向可微收缩一点，避免尾端鼓包
                                const long = Math.max(1e-6, tailL * (1.0 - 0.15 * tau));
                                const dTail = Math.sqrt((par * par) / (long * long) + (perp * perp) / (side *
                                    side));
                                if (dTail <= 1.0) {
                                    const u = dTail;
                                    w = 1.0 - (u * u * (3.0 - 2.0 * u));
                                    inside = true;
                                }
                            }
                        }

                        if (!inside) continue;


                        velArray[p] += dirx * (gainBase * w);
                        velArray[p + 1] += diry * (gainBase * w);

                        scaleLock[base] = 0;
                        const s = scaleArray[base],
                            err = (mulAbs - s);
                        const push = SCALE.followGain * err * w;
                        const maxPush = 2.0;
                        scaleVelArray[base] += Math.max(-maxPush, Math.min(maxPush, push));

                        posKFactor[base] = Math.min(posKFactor[base], posFac);
                        sizeKFactor[base] = Math.min(sizeKFactor[base], sizeFac);
                        lastTouch[base] = performance.now() * 0.001;
                    }
                }
            }

            function injectPathImpulse(x0, y0, x1, y1, speed, vx, vy) {
                const dist = Math.hypot(x1 - x0, y1 - y0);
                const {
                    stepX,
                    stepY
                } = gridMetrics();
                const unit = 0.65 * Math.min(stepX, stepY); // 每 0.65 个格距取一次样本
                const steps = Math.max(1, Math.ceil(dist / unit));
                for (let k = 0; k <= steps; k++) {
                    const t = k / steps;
                    const x = x0 + (x1 - x0) * t;
                    const y = y0 + (y1 - y0) * t;
                    injectAOE(x, y, speed, vx, vy);
                }
            }


            let pluckOn = true,
                pulseOn = true;
            let savedPulseMin = CFG.pulseMin;
            const btnPulse = document.getElementById('pulse');
            const btnPluck = document.getElementById('pluck');

            btnPulse.onclick = () => {
                pulseOn = !pulseOn;
                btnPulse.setAttribute('aria-pressed', pulseOn);
                btnPulse.textContent = `脉动：${pulseOn?'开':'关'} (P)`;
                if (pulseOn) {
                    gl.uniform1f(u_pulseHz, CFG.pulseSpeedHz);
                    gl.uniform1f(u_pulseMin, savedPulseMin);
                    gl.uniform1f(u_pulseOn, 1.0);
                } else {
                    gl.uniform1f(u_pulseHz, 0.0);
                    gl.uniform1f(u_pulseMin, 1.0);
                    gl.uniform1f(u_pulseOn, 0.0);
                }
            };
            btnPluck.onclick = () => {
                pluckOn = !pluckOn;
                btnPluck.setAttribute('aria-pressed', pluckOn);
                btnPluck.textContent = `拨动：${pluckOn?'开':'关'} (O)`;
            };
            addEventListener('keydown', e => {
                if (e.key === 'p' || e.key === 'P') btnPulse.click();
                if (e.key === 'o' || e.key === 'O') btnPluck.click();
            });

            // 绑定 UI
            const id = x => document.getElementById(x);
            const sizeR = id('sizeRange'),
                gapR = id('gapRange'),
                radR = id('radiusRange'),
                spdR = id('speedRange'),
                crR = id('crRange'),
                thR = id('thRange'),
                sigR = id('sigRange'),
                lamR = id('lamRange'),
                fqR = id('fqRange'),
                gamR = id('gamRange'),
                ratioR = id('ratioRange'),
                delayR = id('delayRange'),
                speedCapR = id('speedCapRange'),
                speedEffR = id('speedEffRange'),
                maxCellsR = id('maxCellsRange'),
                maxScaleR = id('maxScaleRange'),
                pluckCapR = id('pluckCapRange'),
                fadeRateR = id('fadeRateRange'),
                speedMinR = id('speedMinRange'),
                dropFrontR = id('dropFrontRange'),
                dropSqueezeR = id('dropSqueezeRange'),
                pulseLamR = id('pulseLamRange'); // ★
            const vSize = id('vSize'),
                vGap = id('vGap'),
                vRad = id('vRadius'),
                vSpd = id('vSpeed'),
                vCR = id('vCR'),
                vTh = id('vTh'),
                vSig = id('vSig'),
                vLam = id('vLam'),
                vFq = id('vFq'),
                vGam = id('vGam'),
                vRatio = id('vRatio'),
                vDelay = id('vDelay'),
                vSCap = id('vSCap'),
                vSEff = id('vSEff'),
                vMS = id('vMS'),
                vMaxCells = id('vMaxCells'),
                vMaxScale = id('vMaxScale'),
                vPluckCap = id('vPluckCap'),
                vFadeRate = id('vFadeRate'),
                vSpeedMin = id('vSpeedMin'),
                vDropFront = id('vDropFront'),
                vDropSqueeze = id('vDropSqueeze'),
                vPulseLam = id('vPulseLam'); // ★
            const capToggle = document.getElementById('capToggle');

            function initSliders() {
                sizeR.value = CFG.size;
                vSize.textContent = CFG.size + ' px';
                gapR.value = CFG.extraGap;
                vGap.textContent = CFG.extraGap + ' px';
                radR.value = CFG.corner;
                vRad.textContent = CFG.corner + ' px';
                spdR.value = CFG.pulseSpeedHz;
                vSpd.textContent = CFG.pulseSpeedHz.toFixed(2) + ' Hz';
                crR.value = CFG.connectRange;
                vCR.textContent = CFG.connectRange.toFixed(1) + ' px';
                thR.value = CFG.threshold;
                vTh.textContent = CFG.threshold.toFixed(2);
                sigR.value = WAVE.sigma;
                vSig.textContent = WAVE.sigma.toFixed(0) + ' px';
                lamR.value = WAVE.lambda;
                vLam.textContent = WAVE.lambda.toFixed(0) + ' px';
                fqR.value = WAVE.freq;
                vFq.textContent = WAVE.freq.toFixed(2) + ' Hz';
                gamR.value = WAVE.gamma;
                vGam.textContent = WAVE.gamma.toFixed(2);
                ratioR.value = PLUCK.ratio;
                vRatio.textContent = PLUCK.ratio.toFixed(3);
                delayR.value = PLUCK.delayMs;
                vDelay.textContent = PLUCK.delayMs + ' ms';
                speedCapR.value = SPEEDBIND.capPx;
                vSCap.textContent = SPEEDBIND.capPx + ' px/s';
                speedEffR.value = SPEEDBIND.effect;
                vSEff.textContent = SPEEDBIND.effect.toFixed(2);
                maxCellsR.value = AOE.maxCells;
                vMaxCells.textContent = AOE.maxCells.toString();
                maxScaleR.value = SCALE.maxScale;
                vMaxScale.textContent = SCALE.maxScale.toFixed(2) + '×';
                pluckCapR.value = PLUCK.capPx;
                vPluckCap.textContent = PLUCK.capPx + ' px/s';
                capToggle.setAttribute('aria-pressed', PLUCK.capEnable);
                capToggle.textContent = `拨动限速：${PLUCK.capEnable?'开':'关'}`;
                fadeRateR.value = FADE.forceRate;
                vFadeRate.textContent = FADE.forceRate.toFixed(1) + '/s';
                speedMinR.value = DROPcfg.speedMin;
                vSpeedMin.textContent = DROPcfg.speedMin + ' px/s';
                dropFrontR.value = DROPcfg.front;
                vDropFront.textContent = DROPcfg.front.toFixed(2);
                dropSqueezeR.value = DROPcfg.squeeze;
                vDropSqueeze.textContent = DROPcfg.squeeze.toFixed(2);

                // ★ 脉动波长
                pulseLamR.value = PULSEFX.lambdaPx;
                vPulseLam.textContent = PULSEFX.lambdaPx + ' px';
                // ★ 脉动样式单选
                document.querySelectorAll('input[name="pulseMode"]').forEach(r => {
                    r.checked = (Number(r.value) === PULSEFX.mode);
                });

                vMS.textContent = '0 px/s';
            }
            sizeR.oninput = () => {
                CFG.size = +sizeR.value;
                vSize.textContent = CFG.size + ' px';
                syncStatics();
            };
            gapR.oninput = () => {
                CFG.extraGap = +gapR.value;
                vGap.textContent = CFG.extraGap + ' px';
                syncStep();
            };
            radR.oninput = () => {
                CFG.corner = +radR.value;
                vRad.textContent = CFG.corner + ' px';
                syncStatics();
            };
            spdR.oninput = () => {
                CFG.pulseSpeedHz = +spdR.value;
                vSpd.textContent = CFG.pulseSpeedHz.toFixed(2) + ' Hz';
                gl.uniform1f(u_pulseHz, CFG.pulseSpeedHz);
            };
            crR.oninput = () => {
                CFG.connectRange = +crR.value;
                vCR.textContent = CFG.connectRange.toFixed(1) + ' px';
                gl.uniform1f(u_falloff, Math.log(2.0) / (Math.max(1e-3, CFG.connectRange) * DPR));
            };
            thR.oninput = () => {
                CFG.threshold = +thR.value;
                vTh.textContent = CFG.threshold.toFixed(2);
                gl.uniform1f(u_thresh, CFG.threshold);
            };
            sigR.oninput = () => {
                WAVE.sigma = +sigR.value;
                vSig.textContent = WAVE.sigma.toFixed(0) + ' px';
            };
            lamR.oninput = () => {
                WAVE.lambda = +lamR.value;
                vLam.textContent = WAVE.lambda.toFixed(0) + ' px';
            };
            fqR.oninput = () => {
                WAVE.freq = +fqR.value;
                vFq.textContent = WAVE.freq.toFixed(2) + ' Hz';
            };
            gamR.oninput = () => {
                WAVE.gamma = +gamR.value;
                vGam.textContent = WAVE.gamma.toFixed(2);
            };
            ratioR.oninput = () => {
                PLUCK.ratio = +ratioR.value;
                vRatio.textContent = PLUCK.ratio.toFixed(3);
            };
            delayR.oninput = () => {
                PLUCK.delayMs = +delayR.value;
                vDelay.textContent = PLUCK.delayMs + ' ms';
            };
            speedCapR.oninput = () => {
                SPEEDBIND.capPx = +speedCapR.value;
                vSCap.textContent = SPEEDBIND.capPx + ' px/s';
            };
            speedEffR.oninput = () => {
                SPEEDBIND.effect = +speedEffR.value;
                vSEff.textContent = SPEEDBIND.effect.toFixed(2);
            };
            maxCellsR.oninput = () => {
                AOE.maxCells = +maxCellsR.value;
                vMaxCells.textContent = AOE.maxCells.toString();
            };
            maxScaleR.oninput = () => {
                SCALE.maxScale = +maxScaleR.value;
                vMaxScale.textContent = SCALE.maxScale.toFixed(2) + '×';
            };
            pluckCapR.oninput = () => {
                PLUCK.capPx = +pluckCapR.value;
                vPluckCap.textContent = PLUCK.capPx + ' px/s';
            };
            capToggle.onclick = () => {
                PLUCK.capEnable = !PLUCK.capEnable;
                capToggle.setAttribute('aria-pressed', PLUCK.capEnable);
                capToggle.textContent = `拨动限速：${PLUCK.capEnable?'开':'关'}`;
            };

            // ★ 脉动样式变化
            document.querySelectorAll('input[name="pulseMode"]').forEach(r => {
                r.addEventListener('change', () => {
                    const val = Number(r.value);
                    if (val === 1 || val === 2) {
                        PULSEFX.mode = val;
                        gl.uniform1i(u_pulseMode, PULSEFX.mode);
                    }
                });
            });
            // ★ 脉动波长
            pulseLamR.oninput = () => {
                PULSEFX.lambdaPx = +pulseLamR.value;
                vPulseLam.textContent = PULSEFX.lambdaPx + ' px';
                gl.uniform1f(u_waveLambda, PULSEFX.lambdaPx * DPR);
            };

            // 水滴面板
            // const fadeRateR=document.getElementById('fadeRateRange');
            // const speedMinR=document.getElementById('speedMinRange');
            // const dropFrontR=document.getElementById('dropFrontRange');
            // const dropSqueezeR=document.getElementById('dropSqueezeRange');
            fadeRateR.oninput = () => {
                FADE.forceRate = +fadeRateR.value;
                document.getElementById('vFadeRate').textContent = FADE.forceRate.toFixed(1) + '/s';
            };
            speedMinR.oninput = () => {
                DROPcfg.speedMin = +speedMinR.value;
                document.getElementById('vSpeedMin').textContent = DROPcfg.speedMin + ' px/s';
            };
            dropFrontR.oninput = () => {
                DROPcfg.front = +dropFrontR.value;
                document.getElementById('vDropFront').textContent = DROPcfg.front.toFixed(2);
            };
            dropSqueezeR.oninput = () => {
                DROPcfg.squeeze = +dropSqueezeR.value;
                document.getElementById('vDropSqueeze').textContent = DROPcfg.squeeze.toFixed(2);
            };

            // 鼠标
            const mouse = {
                x: 0,
                y: 0,
                t: 0
            };
            let instSpeed = 0,
                smoothSpeed = 0;
            addEventListener('pointermove', e => {
                const rect = glCanvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) * DPR;
                const y = glCanvas.height - (e.clientY - rect.top) * DPR;

                const now = performance.now() * 0.001;
                const dt = Math.max(1e-3, now - (mouse.t || now));
                const vx = (x - (mouse.x || x)) / dt,
                    vy = (y - (mouse.y || y)) / dt;
                instSpeed = Math.hypot(vx, vy);
                smoothSpeed = 0.25 * instSpeed + 0.75 * smoothSpeed;
                document.getElementById('vMS').textContent = Math.round(smoothSpeed) + ' px/s';

                if (pluckOn) {
                    const wasFast = (window.__prevSpeed || 0) > STOP.high;
                    const nowSlow = instSpeed < STOP.low;
                    if (wasFast && nowSlow) {
                        settleBubble(x, y);
                    }
                    window.__prevSpeed = instSpeed;

                    if (instSpeed > PLUCK.speedThreshold || (now - (mouse.t || 0)) > 0.08) {
                        injectPathImpulse(mouse.x || x, mouse.y || y, x, y, instSpeed, vx, vy);
                    }
                }
                mouse.x = x;
                mouse.y = y;
                mouse.t = now;
            }, {
                passive: true
            });
            addEventListener('pointerdown', e => {
                const rect = glCanvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) * DPR;
                const y = glCanvas.height - (e.clientY - rect.top) * DPR;
                mouse.x = x;
                mouse.y = y;
                mouse.t = performance.now() * 0.001;
                injectAOE(x, y, 800, 1, 0);
            }, {
                passive: true
            });

            function settleBubble(x, y) {
                const {
                    stepX,
                    stepY
                } = gridMetrics();
                const unit = Math.min(stepX, stepY);
                const rPx = STOP.radiusCells * unit;
                const {
                    i: ic,
                    j: jc
                } = nearestIndex(x, y);
                const rI = Math.ceil(rPx / stepX) + 1,
                    rJ = Math.ceil(rPx / stepY) + 1;
                for (let dj = -rJ; dj <= rJ; dj++) {
                    const j = jc + dj;
                    for (let di = -rI; di <= rI; di++) {
                        const i = ic + di;
                        const base = idx2(i, j);
                        if (base < 0) continue;
                        const p = base * 2;
                        const {
                            cx,
                            cy
                        } = centerOf(i, j);
                        const dx = cx - x,
                            dy = cy - y;
                        if (Math.hypot(dx, dy) > rPx) continue;
                        posKFactor[base] = 1.0;
                        sizeKFactor[base] = 1.0;
                        velArray[p] *= STOP.velCut;
                        velArray[p + 1] *= STOP.velCut;
                        if (Math.abs(scaleArray[base] - 1.0) <= FADE.restScaleEps) {
                            scaleArray[base] = 1.0;
                            scaleVelArray[base] = 0.0;
                            scaleLock[base] = 1;
                        }
                        lastTouch[base] = performance.now() * 0.001;
                    }
                }
            }

            // 渲染
            let t0 = performance.now();

            function frame() {
                stepSprings();
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                gl.uniform1f(u_time, (performance.now() - t0) * 0.001);
                gl.drawArrays(gl.TRIANGLES, 0, 3);
                requestAnimationFrame(frame);
            }

            function boot() {
                resize();
                syncStatics();
                initSliders();
                frame();
            }
            boot();

            // 备用 Canvas2D（不含拨动）
            function startFallback() {
                const ctx = fbCanvas.getContext('2d');

                function resize2() {
                    fbCanvas.width = innerWidth;
                    fbCanvas.height = innerHeight;
                }

                function rr4(ctx, x, y, w, h, rTR, rTL, rBL, rBR) {
                    const rr = v => Math.max(0, Math.min(v, Math.min(w, h) / 2 - 0.5));
                    rTR = rr(rTR);
                    rTL = rr(rTL);
                    rBL = rr(rBL);
                    rBR = rr(rBR);
                    ctx.beginPath();
                    ctx.moveTo(x + rTL, y);
                    ctx.lineTo(x + w - rTR, y);
                    ctx.arcTo(x + w, y, x + w, y + rTR, rTR);
                    ctx.lineTo(x + w, y + h - rBR);
                    ctx.arcTo(x + w, y + h, x + w - rBR, y + h, rBR);
                    ctx.lineTo(x + rBL, y + h);
                    ctx.arcTo(x, y + h, x, y + h - rBL, rBL);
                    ctx.lineTo(x, y + rTL);
                    ctx.arcTo(x, y, x + rTL, y, rTL);
                    ctx.closePath();
                }

                function draw() {
                    ctx.clearRect(0, 0, fbCanvas.width, fbCanvas.height);
                    const s = CFG.size,
                        gap = CFG.extraGap;
                    const stepX = s * 2 + gap,
                        stepY = s + gap;
                    const cx = fbCanvas.width / 2,
                        cy = fbCanvas.height / 2;
                    const t = (performance.now() * 0.001) * CFG.pulseSpeedHz * 2 * Math.PI;
                    const k = CFG.pulseMin + (1 - CFG.pulseMin) * (0.5 + 0.5 * Math.sin(t));
                    const half = s * 0.5 * k,
                        r = Math.min(CFG.corner * k, half - 0.5);
                    ctx.fillStyle = '#fff';
                    for (let j = -1000; j <= 1000; j++) {
                        const rowOff = (Math.abs(j) % 2) * 0.5;
                        const y = cy + j * stepY;
                        if (y < -s * 2 || y > fbCanvas.height + s * 2) continue;
                        for (let i = -1000; i <= 1000; i++) {
                            const x = cx + (i + rowOff) * stepX;
                            if (x < -s * 2 || x > fbCanvas.width + s * 2) continue;
                            rr4(ctx, x - half, y - half, half * 2, half * 2, r, 0, r, 0);
                            ctx.fill();
                        }
                    }
                    requestAnimationFrame(draw);
                }
                addEventListener('resize', resize2);
                resize2();
                draw();
            }

        })();
    </script>
</body>

</html>