<!doctype html>
<html lang="zh-CN">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>十字→圆角方块阵列（WebGL 2D + 交互形变）</title>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            background: #0b0f14;
            color: #e6eefc;
            font-family: system-ui, Segoe UI, Roboto, Helvetica, Arial
        }

        canvas {
            position: fixed;
            inset: 0;
            display: block;
            width: 100%;
            height: 100%
        }

        .ui {
            position: fixed;
            left: 16px;
            top: 16px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10;
            width: min(340px, 92vw);
            max-height: calc(100vh - 32px);
            overflow: auto;
            padding: 12px;
            border: 1px solid #2a3340;
            background: #0f1522;
            border-radius: 10px
        }

        .row {
            display: grid;
            grid-template-columns: 1fr auto;
            align-items: center;
            gap: 10px
        }

        .row input[type="range"] {
            width: 180px
        }

        .row input[type="checkbox"] {
            transform: scale(1.2)
        }

        .mono {
            font-family: ui-monospace, Menlo, monospace
        }

        .small {
            opacity: .8;
            font-size: 12px
        }

        .btn {
            cursor: pointer;
            border: 1px solid #2a3340;
            background: #101825;
            color: #e6eefc;
            padding: 6px 10px;
            border-radius: 8px
        }
    </style>
</head>

<body>
    <canvas id="gl"></canvas>

    <div class="ui">
        <div class="row"><label>Grid 步长(px)</label><input id="grid" type="range" min="30" max="160" step="1"
                value="90"><span id="grid_v" class="mono">90</span></div>
        <div class="row"><label>臂半长 ratio（相对 Grid）</label><input id="arm" type="range" min="0.30" max="0.95" step="0.01"
                value="0.56"><span id="arm_v" class="mono">0.56</span></div>
        <div class="row"><label>臂厚 ratio（相对 Grid）</label><input id="thick" type="range" min="0.05" max="0.95"
                step="0.01" value="0.48"><span id="thick_v" class="mono">0.48</span></div>
        <div class="row"><label>黑色夹角圆角上限(px)</label><input id="corner" type="range" min="2" max="40" step="1"
                value="16"><span id="corner_v" class="mono">16</span></div>
        <div class="row"><label>全局放大倍率</label><input id="scale" type="range" min="0.30" max="1.30" step="0.01"
                value="1.00"><span id="scale_v" class="mono">1.00</span></div>
        <div class="row"><label>交互半径(px)</label><input id="rad" type="range" min="40" max="400" step="1"
                value="220"><span id="rad_v" class="mono">220</span></div>
        <div class="row"><label>交互强度</label><input id="force" type="range" min="0.00" max="1.50" step="0.01"
                value="0.85"><span id="force_v" class="mono">0.85</span></div>
        <div class="row"><label>剪切量（平行四边形感）</label><input id="shear" type="range" min="0.00" max="1.00" step="0.01"
                value="0.35"><span id="shear_v" class="mono">0.35</span></div>
        <div class="row"><label>显示网格线</label><input id="gridshow" type="checkbox" checked><span></span></div>
        <div class="row"><button id="s1" class="btn">状态1(缩小)</button><span class="small">臂厚↓ 比例小、断开</span></div>
        <div class="row"><button id="s2" class="btn">状态2(正常)</button><span class="small">臂厚≈间隔，圆角对称</span></div>
        <div class="row"><button id="s3" class="btn">状态3(放大)</button><span class="small">放大但黑角圆角钳制</span></div>
    </div>

    <script>
        const vert = `#version 300 es
precision highp float;
layout(location=0) in vec2 aPos;
out vec2 vUV;
void main(){
  vUV = aPos*0.5+0.5;
  gl_Position = vec4(aPos,0.0,1.0);
}`;

        const frag = `#version 300 es
precision highp float;
out vec4 o;
in vec2 vUV;

uniform vec2  uRes;
uniform float uTime;
uniform vec2  uMouse;       // 像素坐标
uniform vec2  uMVel;        // 像素/秒近似
uniform bool  uDown;

uniform float uGrid;        // 网格间距（线与线的间距，单位px）
uniform float uArmRatio;    // 十字臂半长 / Grid
uniform float uThickRatio;  // 十字臂厚 / Grid
uniform float uScale;       // 全局放大
uniform float uCornerMax;   // 斜对角并集平滑半径（黑色夹角的“最大圆角”）
uniform float uInteractR;   // 交互半径
uniform float uForce;       // 交互强度（各向异性缩放）
uniform float uShear;       // 剪切量
uniform bool  uShowGrid;

// —— 工具函数 —— //
float smin(float a, float b, float k){ // smooth min (polynomial)
  k = max(k, 1e-6);
  float h = clamp(0.5 + 0.5*(b - a)/k, 0.0, 1.0);
  return mix(b, a, h) - k*h*(1.0 - h);
}

// 圆角矩形 SDF
float sdRoundRect(vec2 p, vec2 b, float r){
  vec2 q = abs(p) - b;
  return length(max(q,0.0)) + min(max(q.x,q.y),0.0) - r;
}

// 十字：两个圆角矩形的并集（横臂 + 竖臂）
float sdRoundedCross(vec2 p, float halfLen, float halfThick, float r){
  float dh = sdRoundRect(p, vec2(halfLen, halfThick), r);
  float dv = sdRoundRect(p, vec2(halfThick, halfLen), r);
  return min(dh, dv);
}

// 最近的“棋盘相位”格点向量（(0,0) 与 (L,L) 两个晶格）
vec2 nearestOnLattice(vec2 p, float L, vec2 off){ // off = (0,0) 或 (L,L)
  vec2 q = (p - off) / (2.0*L);
  vec2 base = round(q) * (2.0*L) + off;
  return p - base; // 指向最近格点的向量
}

// 将坐标在鼠标附近做各向异性缩放 + 剪切（方向对齐鼠标速度），产生压缩/拉伸/平行四边形变形
vec2 warp(vec2 p){
  vec2 m = uMouse;
  float R = uInteractR;
  float d = distance(p, m);
  float w = exp(- (d*d) / (2.0*R*R)); // 高斯权重

  // 速度方向（没动就用一个固定方向避免 NaN）
  vec2 dir = normalize((length(uMVel) > 1.0) ? uMVel : vec2(1.0,0.0));
  vec2 per = vec2(-dir.y, dir.x);

  // 以鼠标为原点建立局部基
  vec2 q = p - m;
  // 坐标投到 {dir, per}
  vec2 ab = vec2(dot(q, dir), dot(q, per));

  // 各向异性缩放（沿速度方向放大，垂直方向压缩），并加入剪切
  float k = uForce * w;
  float sh = uShear * w;
  mat2 M = mat2(1.0 + k, sh,
                0.0,      1.0 - k);

  ab = M * ab;

  // 再变回屏幕坐标
  q = dir*ab.x + per*ab.y;
  return m + q;
}

void main(){
  // 像素坐标，以屏幕中心为 (0,0)
  vec2 uv = vUV;
  vec2 p = (uv * uRes) - 0.5*uRes;

  // 交互形变（只操作坐标，不直接“拉扯颜色”，保证拓扑连续）
  p = warp(p);

  // 可调参数换算到像素
  float L  = uGrid;                       // 网格线间距
  float aL = uArmRatio   * L * uScale;    // 臂半长（像素）
  float tH = 0.5 * uThickRatio * L * uScale; // 臂半厚（像素）
  float r  = min( min(aL,tH), 0.95*L );   // 十字自身的圆角（臂端/转角微圆）
  float kCorner = uCornerMax;             // 斜对角 smooth 并集半径（黑色夹角“最大圆角”）

  // 两个相位的晶格（步长 2L）：(0,0) 与 (L,L)，对应“隔一个交叉点放一个”的棋盘布置
  vec2 v1 = nearestOnLattice(p, L, vec2(0.0));
  vec2 v2 = nearestOnLattice(p, L, vec2(L));

  // 各自的“十字”距离场
  float d1 = sdRoundedCross(v1, aL, tH, r);
  float d2 = sdRoundedCross(v2, aL, tH, r);

  // 对角相邻用 smooth-min 做并集，kCorner 控制黑色夹角的圆角，且保持为常量（不会随缩放继续变大）
  float d = smin(d1, d2, kCorner);

  // 抗锯齿
  float aa = fwidth(d);
  float alpha = smoothstep(aa, -aa, d);

  vec3 col = vec3(1.0);        // 方块白色
  vec3 bg  = vec3(0.045,0.06,0.08); // 背景深色
  vec3 rgb = mix(bg, col, alpha);

  // 可选网格线覆盖（细线）
  if(uShowGrid){
    // 以 L 为周期的网格线（比方块的小一层）
    vec2 gp = (p + 0.5*L); // 移一点防止线上闪烁
    vec2 g = abs(fract(gp / L) - 0.5) * L;
    float line = min(g.x, g.y);
    float lw = 1.0; // 线宽（像素）
    float glAlpha = 1.0 - smoothstep(lw, lw+1.0, line);
    vec3 gridCol = vec3(0.14,0.17,0.22);
    rgb = mix(rgb, gridCol, glAlpha*0.9);
  }

  o = vec4(rgb, 1.0);
}
`;

        const canvas = document.getElementById('gl');
        const gl = canvas.getContext('webgl2', {
            antialias: true
        });
        if (!gl) {
            alert('需要 WebGL2 支持');
        }

        function resize() {
            const dpr = Math.max(1, window.devicePixelRatio || 1);
            const w = Math.floor(innerWidth * dpr);
            const h = Math.floor(innerHeight * dpr);
            canvas.width = w;
            canvas.height = h;
            canvas.style.width = '100%';
            canvas.style.height = '100%';
            gl.viewport(0, 0, w, h);
        }
        addEventListener('resize', resize, {
            passive: true
        });
        resize();

        // 编译
        function compile(type, src) {
            const sh = gl.createShader(type);
            gl.shaderSource(sh, src);
            gl.compileShader(sh);
            if (!gl.getShaderParameter(sh, gl.COMPILE_STATUS)) {
                console.error(gl.getShaderInfoLog(sh));
                throw new Error('shader compile failed');
            }
            return sh;
        }
        const vs = compile(gl.VERTEX_SHADER, vert);
        const fs = compile(gl.FRAGMENT_SHADER, frag);
        const prog = gl.createProgram();
        gl.attachShader(prog, vs);
        gl.attachShader(prog, fs);
        gl.linkProgram(prog);
        if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
            console.error(gl.getProgramInfoLog(prog));
            throw new Error('link failed');
        }
        gl.useProgram(prog);

        // 全屏三角形
        const buf = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, buf);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
            -1, -1, 3, -1, -1, 3
        ]), gl.STATIC_DRAW);
        gl.enableVertexAttribArray(0);
        gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);

        // uniforms
        const U = {
            uRes: gl.getUniformLocation(prog, 'uRes'),
            uTime: gl.getUniformLocation(prog, 'uTime'),
            uMouse: gl.getUniformLocation(prog, 'uMouse'),
            uMVel: gl.getUniformLocation(prog, 'uMVel'),
            uDown: gl.getUniformLocation(prog, 'uDown'),
            uGrid: gl.getUniformLocation(prog, 'uGrid'),
            uArmRatio: gl.getUniformLocation(prog, 'uArmRatio'),
            uThickRatio: gl.getUniformLocation(prog, 'uThickRatio'),
            uScale: gl.getUniformLocation(prog, 'uScale'),
            uCornerMax: gl.getUniformLocation(prog, 'uCornerMax'),
            uInteractR: gl.getUniformLocation(prog, 'uInteractR'),
            uForce: gl.getUniformLocation(prog, 'uForce'),
            uShear: gl.getUniformLocation(prog, 'uShear'),
            uShowGrid: gl.getUniformLocation(prog, 'uShowGrid'),
        };

        const state = {
            grid: 90,
            arm: 0.56,
            thick: 0.48,
            corner: 16,
            scale: 1.00,
            rad: 220,
            force: 0.85,
            shear: 0.35,
            showGrid: true,
        };

        function bindSlider(id, key) {
            const el = document.getElementById(id);
            const lab = document.getElementById(id + '_v');
            const update = () => {
                state[key] = parseFloat(el.value);
                if (lab) lab.textContent = el.value;
            };
            el.addEventListener('input', update);
            update();
        }
        bindSlider('grid', 'grid');
        bindSlider('arm', 'arm');
        bindSlider('thick', 'thick');
        bindSlider('corner', 'corner');
        bindSlider('scale', 'scale');
        bindSlider('rad', 'rad');
        bindSlider('force', 'force');
        bindSlider('shear', 'shear');
        const gridshow = document.getElementById('gridshow');
        gridshow.addEventListener('change', () => state.showGrid = gridshow.checked);
        state.showGrid = gridshow.checked;

        // 三个快捷按钮：状态1/2/3
        document.getElementById('s1').onclick = () => {
            state.scale = 0.72;
            document.getElementById('scale').value = state.scale;
            scale_v.textContent = state.scale;
            state.thick = 0.18;
            document.getElementById('thick').value = state.thick;
            thick_v.textContent = state.thick;
        };
        document.getElementById('s2').onclick = () => {
            state.scale = 1.00;
            document.getElementById('scale').value = state.scale;
            scale_v.textContent = state.scale;
            state.thick = 0.48;
            document.getElementById('thick').value = state.thick;
            thick_v.textContent = state.thick;
        };
        document.getElementById('s3').onclick = () => {
            state.scale = 1.22;
            document.getElementById('scale').value = state.scale;
            scale_v.textContent = state.scale;
            state.thick = 0.78;
            document.getElementById('thick').value = state.thick;
            thick_v.textContent = state.thick;
        };

        // 鼠标
        let mouse = {
            x: 0,
            y: 0,
            down: false
        };
        let last = {
            x: 0,
            y: 0,
            t: performance.now()
        };
        let mvel = {
            x: 0,
            y: 0
        };

        function setMouse(e) {
            const rect = canvas.getBoundingClientRect();
            const dpr = Math.max(1, window.devicePixelRatio || 1);
            mouse.x = (e.clientX - rect.left) * dpr;
            mouse.y = (rect.height - (e.clientY - rect.top)) * dpr; // 转为自下而上
        }
        addEventListener('mousemove', (e) => {
            setMouse(e);
        });
        addEventListener('touchmove', (e) => {
            if (e.touches.length) {
                setMouse(e.touches[0]);
            }
        }, {
            passive: true
        });
        addEventListener('mousedown', e => {
            mouse.down = true;
            setMouse(e);
        });
        addEventListener('mouseup', () => {
            mouse.down = false;
        });
        addEventListener('touchstart', e => {
            mouse.down = true;
            if (e.touches.length) {
                setMouse(e.touches[0]);
            }
        }, {
            passive: true
        });
        addEventListener('touchend', () => {
            mouse.down = false;
        }, {
            passive: true
        });

        function frame(t) {
            requestAnimationFrame(frame);

            // 计算近似速度（像素/秒）
            const now = performance.now();
            const dt = (now - last.t) / 1000;
            const vx = (mouse.x - last.x) / Math.max(dt, 1e-5);
            const vy = (mouse.y - last.y) / Math.max(dt, 1e-5);
            // 简单低通
            mvel.x = mvel.x * 0.85 + vx * 0.15;
            mvel.y = mvel.y * 0.85 + vy * 0.15;
            last.x = mouse.x;
            last.y = mouse.y;
            last.t = now;

            gl.useProgram(prog);
            gl.uniform2f(U.uRes, canvas.width, canvas.height);
            gl.uniform1f(U.uTime, t * 0.001);
            gl.uniform2f(U.uMouse, mouse.x, mouse.y);
            gl.uniform2f(U.uMVel, mvel.x, mvel.y);
            gl.uniform1i(U.uDown, mouse.down ? 1 : 0);

            gl.uniform1f(U.uGrid, state.grid);
            gl.uniform1f(U.uArmRatio, state.arm);
            gl.uniform1f(U.uThickRatio, state.thick);
            gl.uniform1f(U.uScale, state.scale);
            gl.uniform1f(U.uCornerMax, state.corner);
            gl.uniform1f(U.uInteractR, state.rad);
            gl.uniform1f(U.uForce, state.force);
            gl.uniform1f(U.uShear, state.shear);
            gl.uniform1i(U.uShowGrid, state.showGrid ? 1 : 0);

            gl.drawArrays(gl.TRIANGLES, 0, 3);
        }
        requestAnimationFrame(frame);
    </script>
</body>

</html>