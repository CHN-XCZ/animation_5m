<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>
      中心锚定 · 交错排列 · 环形外观的实心方圆（k与n可调 / 本地存储）
    </title>
    <style>
      html,
      body {
        height: 100%;
        margin: 0;
        background: #000;
      }
      canvas {
        position: fixed;
        inset: 0;
        width: 100%;
        height: 100%;
        display: block;
      }
      .ui {
        position: fixed;
        left: 14px;
        top: 14px;
        z-index: 5;
        color: #cdd6f4;
        font: 12px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu,
          "Noto Sans", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei",
          sans-serif;
        background: #0b0f14cc;
        border: 1px solid #1c2636;
        border-radius: 12px;
        padding: 10px 12px;
        backdrop-filter: blur(6px);
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
        max-width: min(96vw, 1000px);
      }
      .ui label {
        display: flex;
        align-items: center;
        gap: 6px;
        white-space: nowrap;
      }
      .ui input[type="range"] {
        width: 140px;
      }
      .ui input[type="number"] {
        width: 76px;
        padding: 4px 6px;
        border-radius: 8px;
        border: 1px solid #1c2636;
        background: #0b0f14;
        color: #cdd6f4;
      }
      .ui .mono {
        font-feature-settings: "tnum";
        font-variant-numeric: tabular-nums;
      }
    </style>
  </head>
  <body>
    <canvas id="c"></canvas>

    <div class="ui">
      <label
        >格子边长
        <input id="cell" type="range" min="12" max="120" step="1" />
        <span class="mono" id="cellv"></span>px
      </label>

      <label
        >横间隔
        <input id="gapX" type="number" min="0" max="240" step="1" />
        <span class="mono">px</span>
      </label>
      <label
        >纵间隔
        <input id="gapY" type="number" min="0" max="240" step="1" />
        <span class="mono">px</span>
      </label>

      <label
        >比例
        <input id="scale" type="range" min="0.25" max="3" step="0.01" />
        <span class="mono" id="scalev"></span>×
      </label>

      <label
        >最小（0~1）
        <input id="minS" type="range" min="0" max="1" step="0.01" />
        <span class="mono" id="minSv"></span>
      </label>

      <label
        >最大（0~2）
        <input id="maxS" type="range" min="0" max="2" step="0.01" />
        <span class="mono" id="maxSv"></span>
      </label>

      <label
        >呼吸时长
        <input id="period" type="range" min="1.5" max="10" step="0.1" />
        <span class="mono" id="periodv"></span>s
      </label>

      <label><input id="breath" type="checkbox" /> 开启呼吸</label>

      <label
        >圆角 n
        <input id="nPow" type="range" min="2" max="12" step="0.1" />
        <span class="mono" id="nPowv"></span>
      </label>

      <label
        >粘连 k（0~1·节距比）
        <input id="kFac" type="range" min="0" max="0.7" step="0.01" />
        <span class="mono" id="kFacv"></span>
      </label>
    </div>

    <script>
      // ---------- WebGL ----------
      const canvas = document.getElementById("c");
      const gl = canvas.getContext("webgl", {
        antialias: false,
        depth: false,
        stencil: false,
        premultipliedAlpha: false,
      });
      if (!gl) {
        alert("WebGL 不可用");
        throw new Error("no webgl");
      }

      function resize() {
        const dpr = Math.min(devicePixelRatio || 1, 2);
        canvas.width = Math.floor(innerWidth * dpr);
        canvas.height = Math.floor(innerHeight * dpr);
        gl.viewport(0, 0, canvas.width, canvas.height);
      }
      addEventListener("resize", resize, { passive: true });
      resize();

      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

      const vertSrc = `
  attribute vec2 aPos;
  void main(){ gl_Position = vec4(aPos,0.0,1.0); }`;

      const fragSrc = `
  precision highp float;
  uniform vec2  uRes;
  uniform float uTime;
  uniform float uCell;     // 基础边长
  uniform vec2  uGap;      // 基础间隔
  uniform float uScale;    // 整体缩放
  uniform float uMinS;
  uniform float uMaxS;
  uniform float uPeriod;
  uniform float uBreathe;  // 0关 1开
  uniform float uAA;       // AA宽度（像素）
  uniform float uNPow;     // 超椭圆指数（圆角程度）
  uniform float uKFac;     // smin 粘连半径系数（相对于节距最小维）

  float sdSuperEllipse(vec2 p, vec2 r, float n){
    p = abs(p) / r;
    float k = pow(pow(p.x, n) + pow(p.y, n), 1.0 / n);
    return (k - 1.0) * min(r.x, r.y);
  }

  vec2 nearestCenterRect(vec2 pos, vec2 pitch, vec2 anchor){
    vec2 idx = floor((pos - anchor) / pitch + 0.5);
    return anchor + pitch * idx;
  }

  float smin(float a, float b, float k){
    float hk = max(1e-4, k);
    float h = clamp(0.5 + 0.5*(b - a)/hk, 0.0, 1.0);
    return mix(b, a, h) - hk*h*(1.0 - h);
  }

  void main(){
    vec2 frag   = gl_FragCoord.xy;
    vec2 center = uRes * 0.5;

    // 缩放后的尺寸与节距
    float cellS = uCell * uScale;
    vec2  gapS  = uGap  * uScale;
    vec2  pitch = vec2(cellS + gapS.x, cellS + gapS.y);

    // 呼吸
    float t = uTime / max(uPeriod, 1e-4);
    float breathe = (uBreathe > 0.5) ? (0.5 + 0.5 * sin(6.2831853 * t)) : 1.0;
    float s = (uBreathe > 0.5) ? mix(uMinS, uMaxS, breathe) : uMaxS;

    // 两套晶格：中心锚定 + 半节距偏移（确保中心有方块）
    vec2 c0 = nearestCenterRect(frag, pitch, center);
    vec2 c1 = nearestCenterRect(frag, pitch, center + 0.5 * pitch);

    // 环外沿的半径；内部补满（用外沿做AA）
    float outerR = 0.5 * cellS * s;
    vec2  r      = vec2(outerR);

    float d0 = sdSuperEllipse(frag - c0, r, uNPow);
    float d1 = sdSuperEllipse(frag - c1, r, uNPow);

    // 粘连半径：由滑块直接控制（相对于节距的最小分量）
    float base = min(cellS, min(pitch.x, pitch.y));
    float k = uKFac * base;

    float d = smin(d0, d1, k);

    // 实心：外沿以内为 1，边缘做 AA
    float alpha = 1.0 - smoothstep(0.0, uAA, d);
    gl_FragColor = vec4(vec3(1.0), alpha);
  }`;

      function sh(type, src) {
        const s = gl.createShader(type);
        gl.shaderSource(s, src);
        gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
          console.error(gl.getShaderInfoLog(s));
          throw new Error(gl.getShaderInfoLog(s) || "shader compile failed");
        }
        return s;
      }
      function prog(vs, fs) {
        const p = gl.createProgram();
        gl.attachShader(p, vs);
        gl.attachShader(p, fs);
        gl.linkProgram(p);
        if (!gl.getProgramParameter(p, gl.LINK_STATUS)) {
          console.error(gl.getProgramInfoLog(p));
          throw new Error(gl.getProgramInfoLog(p) || "link failed");
        }
        return p;
      }

      const vs = sh(gl.VERTEX_SHADER, vertSrc);
      const fs = sh(gl.FRAGMENT_SHADER, fragSrc);
      const pr = prog(vs, fs);
      gl.useProgram(pr);

      // 全屏三角形
      const buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buf);
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array([-1, -1, 3, -1, -1, 3]),
        gl.STATIC_DRAW
      );
      const loc = gl.getAttribLocation(pr, "aPos");
      gl.enableVertexAttribArray(loc);
      gl.vertexAttribPointer(loc, 2, gl.FLOAT, false, 0, 0);

      // uniforms
      const uRes = gl.getUniformLocation(pr, "uRes");
      const uTime = gl.getUniformLocation(pr, "uTime");
      const uCell = gl.getUniformLocation(pr, "uCell");
      const uGap = gl.getUniformLocation(pr, "uGap");
      const uScale = gl.getUniformLocation(pr, "uScale");
      const uMinS = gl.getUniformLocation(pr, "uMinS");
      const uMaxS = gl.getUniformLocation(pr, "uMaxS");
      const uPeriod = gl.getUniformLocation(pr, "uPeriod");
      const uBreathe = gl.getUniformLocation(pr, "uBreathe");
      const uAA = gl.getUniformLocation(pr, "uAA");
      const uNPow = gl.getUniformLocation(pr, "uNPow");
      const uKFac = gl.getUniformLocation(pr, "uKFac");

      // ---------- UI + 本地存储 ----------
      const $ = (id) => document.getElementById(id);
      const cell = $("cell"),
        cellv = $("cellv");
      const gapX = $("gapX");
      const gapY = $("gapY");
      const scale = $("scale"),
        scalev = $("scalev");
      const minS = $("minS"),
        minSv = $("minSv");
      const maxS = $("maxS"),
        maxSv = $("maxSv");
      const period = $("period"),
        periodv = $("periodv");
      const breath = $("breath");
      const nPow = $("nPow"),
        nPowv = $("nPowv");
      const kFac = $("kFac"),
        kFacv = $("kFacv");

      const KEY = "grid_ring_filled_cfg_v2";
      const defaults = {
        cell: 40,
        gapX: 12,
        gapY: 12,
        scale: 1.0,
        minS: 0.9,
        maxS: 1.0,
        period: 4.0,
        breath: true,
        nPow: 4.0,
        kFac: 0.35,
      };
      function loadCfg() {
        try {
          return Object.assign(
            {},
            defaults,
            JSON.parse(localStorage.getItem(KEY) || "{}")
          );
        } catch (e) {
          return { ...defaults };
        }
      }
      function saveCfg() {
        const cfg = {
          cell: +cell.value,
          gapX: +gapX.value,
          gapY: +gapY.value,
          scale: +scale.value,
          minS: +minS.value,
          maxS: +maxS.value,
          period: +period.value,
          breath: !!breath.checked,
          nPow: +nPow.value,
          kFac: +kFac.value,
        };
        localStorage.setItem(KEY, JSON.stringify(cfg));
      }

      function setUniforms() {
        gl.uniform2f(uRes, canvas.width, canvas.height);
        gl.uniform1f(uCell, +cell.value);
        gl.uniform2f(uGap, Math.max(0, +gapX.value), Math.max(0, +gapY.value));
        gl.uniform1f(uScale, +scale.value);
        gl.uniform1f(uMinS, +minS.value);
        gl.uniform1f(uMaxS, +maxS.value);
        gl.uniform1f(uPeriod, +period.value);
        gl.uniform1f(uBreathe, breath.checked ? 1.0 : 0.0);
        gl.uniform1f(uAA, 1.25); // AA像素宽度
        gl.uniform1f(uNPow, +nPow.value);
        gl.uniform1f(uKFac, +kFac.value);
      }
      function syncLabels() {
        cellv.textContent = (+cell.value).toFixed(0);
        scalev.textContent = (+scale.value).toFixed(2);
        minSv.textContent = (+minS.value).toFixed(2);
        maxSv.textContent = (+maxS.value).toFixed(2);
        periodv.textContent = (+period.value).toFixed(1);
        nPowv.textContent = (+nPow.value).toFixed(1);
        kFacv.textContent = (+kFac.value).toFixed(2);
      }
      function syncAll() {
        syncLabels();
        setUniforms();
        saveCfg();
      }

      // 初始化
      (function initUI() {
        const cfg = loadCfg();
        cell.value = cfg.cell;
        gapX.value = cfg.gapX;
        gapY.value = cfg.gapY;
        scale.value = cfg.scale;
        minS.value = cfg.minS;
        maxS.value = cfg.maxS;
        period.value = cfg.period;
        breath.checked = cfg.breath;
        nPow.value = cfg.nPow;
        kFac.value = cfg.kFac;
        syncAll();
      })();

      [cell, gapX, gapY, scale, minS, maxS, period, breath, nPow, kFac].forEach(
        (e) => {
          e.addEventListener("input", syncAll);
          e.addEventListener("change", syncAll);
        }
      );
      addEventListener(
        "resize",
        () => {
          resize();
          setUniforms();
        },
        { passive: true }
      );

      // ---------- render ----------
      gl.clearColor(0, 0, 0, 1);
      let start = performance.now();
      function tick(t) {
        gl.uniform1f(uTime, (t - start) / 1000);
        gl.drawArrays(gl.TRIANGLES, 0, 3);
        requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);
    </script>
  </body>
</html>
